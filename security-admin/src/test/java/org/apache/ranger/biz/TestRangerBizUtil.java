/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.ranger.biz;

import org.apache.ranger.common.AppConstants;
import org.apache.ranger.common.ContextUtil;
import org.apache.ranger.common.GUIDUtil;
import org.apache.ranger.common.MessageEnums;
import org.apache.ranger.common.RESTErrorUtil;
import org.apache.ranger.common.RangerConstants;
import org.apache.ranger.common.StringUtil;
import org.apache.ranger.common.UserSessionBase;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAssetDao;
import org.apache.ranger.db.XXDBBaseDao;
import org.apache.ranger.db.XXGroupDao;
import org.apache.ranger.db.XXPermMapDao;
import org.apache.ranger.db.XXPortalUserDao;
import org.apache.ranger.db.XXResourceDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.db.XXTrxLogV2Dao;
import org.apache.ranger.db.XXUserDao;
import org.apache.ranger.entity.XXAsset;
import org.apache.ranger.entity.XXGroup;
import org.apache.ranger.entity.XXPermMap;
import org.apache.ranger.entity.XXPortalUser;
import org.apache.ranger.entity.XXResource;
import org.apache.ranger.entity.XXService;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.entity.XXTrxLogV2;
import org.apache.ranger.entity.XXUser;
import org.apache.ranger.plugin.model.RangerService;
import org.apache.ranger.plugin.model.RangerServiceHeaderInfo;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.rest.ServiceREST;
import org.apache.ranger.security.context.RangerAdminOpContext;
import org.apache.ranger.security.context.RangerContextHolder;
import org.apache.ranger.security.context.RangerSecurityContext;
import org.apache.ranger.service.XUserService;
import org.apache.ranger.view.VXPortalUser;
import org.apache.ranger.view.VXResource;
import org.apache.ranger.view.VXResponse;
import org.apache.ranger.view.VXStringList;
import org.apache.ranger.view.VXUser;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.WebApplicationException;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @generated by Cursor
 * @description <Unit Test for TestRangerBizUtil class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerBizUtil {
    @InjectMocks
    RangerBizUtil rangerBizUtil = new RangerBizUtil();
    @Mock
    RangerDaoManager daoManager;
    @Mock
    StringUtil stringUtil;
    @Mock
    VXUser vXUser;
    @Mock
    UserMgr userMgr;
    @Mock
    ContextUtil contextUtil;
    @Mock
    RangerSecurityContext context;
    @Mock
    UserSessionBase currentUserSession;
    @Mock
    RESTErrorUtil restErrorUtil;
    @Mock
    VXResponse vXResponse;
    private final Long   id           = 1L;
    private final String resourceName = "hadoopdev";

    @BeforeEach
    public void setup() {
        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(new UserSessionBase());
        RangerContextHolder.setSecurityContext(context);
    }

    @Test
    public void testGetDBFlavor() {
        int dbFlavor = RangerBizUtil.getDBFlavor();
        Assertions.assertEquals(AppConstants.DB_FLAVOR_UNKNOWN, dbFlavor);
    }

    @Test
    public void testGetDBFlavorType() {
        int    dbFlavor      = 1;
        String dbFlavourType = RangerBizUtil.getDBFlavorType(dbFlavor);
        Assertions.assertEquals("MYSQL", dbFlavourType);
        dbFlavor      = 2;
        dbFlavourType = RangerBizUtil.getDBFlavorType(dbFlavor);
        Assertions.assertEquals("ORACLE", dbFlavourType);
    }

    @Test
    public void testGetDBQuery() {
        int    dbFlavor = 1;
        String dbQuery  = RangerBizUtil.getDBVersionQuery(dbFlavor);
        Assertions.assertEquals("SELECT version()", dbQuery);
        dbFlavor = 2;
        dbQuery  = RangerBizUtil.getDBVersionQuery(dbFlavor);
        Assertions.assertEquals("SELECT banner from v$version where rownum<2", dbQuery);
        dbFlavor = 3;
        dbQuery  = RangerBizUtil.getDBVersionQuery(dbFlavor);
        Assertions.assertEquals("SELECT version()", dbQuery);
        dbFlavor = 5;
        dbQuery  = RangerBizUtil.getDBVersionQuery(dbFlavor);
        Assertions.assertEquals("SELECT @@version", dbQuery);
    }

    @Test
    public void testHasPermission_When_disableAccessControl() {
        VXResource vXResource = null;
        rangerBizUtil.enableResourceAccessControl = false;
        VXResponse resp = rangerBizUtil.hasPermission(vXResource, AppConstants.XA_PERM_TYPE_UNKNOWN);
        Assertions.assertNotNull(resp);
    }

    @Test
    public void testHasPermission_When_NoResource() {
        VXResource vXResource = null;
        VXResponse resp       = rangerBizUtil.hasPermission(vXResource, AppConstants.XA_PERM_TYPE_UNKNOWN);
        Assertions.assertNotNull(resp);
        Assertions.assertEquals(VXResponse.STATUS_ERROR, resp.getStatusCode());
        Assertions.assertEquals("Please provide valid policy.", resp.getMsgDesc());
    }

    @Test
    public void testHasPermission_emptyResourceName() {
        VXResource vXResource = new VXResource();
        vXResource.setAssetId(12345L);
        XXPortalUser portalUser = new XXPortalUser();
        portalUser.setId(id);
        portalUser.setLoginId("12121");
        RangerContextHolder.getSecurityContext().getUserSession().setXXPortalUser(portalUser);

        XXUserDao        xxUserDao     = Mockito.mock(XXUserDao.class);
        XXPortalUserDao  userDao       = Mockito.mock(XXPortalUserDao.class);
        XXUser           xxUser        = new XXUser();
        XXAsset          xxAsset       = new XXAsset();
        List<XXResource> lst           = new ArrayList<>();
        XXResourceDao    xxResourceDao = Mockito.mock(XXResourceDao.class);
        XXAssetDao       xxAssetDao    = Mockito.mock(XXAssetDao.class);
        Mockito.when(daoManager.getXXPortalUser()).thenReturn(userDao);
        Mockito.when(userDao.getById(Mockito.anyLong())).thenReturn(portalUser);
        Mockito.when(daoManager.getXXUser()).thenReturn(xxUserDao);
        Mockito.when(xxUserDao.findByUserName(Mockito.anyString())).thenReturn(xxUser);
        Mockito.when(daoManager.getXXResource()).thenReturn(xxResourceDao);
        Mockito.when(xxResourceDao.findByAssetIdAndResourceStatus(Mockito.anyLong(), Mockito.anyInt())).thenReturn(lst);
        Mockito.when(daoManager.getXXAsset()).thenReturn(xxAssetDao);
        Mockito.when(xxAssetDao.getById(Mockito.anyLong())).thenReturn(xxAsset);
        VXResponse resp = rangerBizUtil.hasPermission(vXResource, AppConstants.XA_PERM_TYPE_UNKNOWN);
        Mockito.verify(daoManager).getXXPortalUser();
        Mockito.verify(userDao).getById(Mockito.anyLong());
        Mockito.verify(daoManager).getXXUser();
        Mockito.verify(xxUserDao).findByUserName(Mockito.anyString());
        Assertions.assertNotNull(resp);
        Assertions.assertEquals(VXResponse.STATUS_ERROR, resp.getStatusCode());
        Assertions.assertEquals("Permission Denied !", resp.getMsgDesc());
    }

    @Test
    public void testHasPermission_isAdmin() {
        VXResource vXResource = new VXResource();
        vXResource.setName(resourceName);
        vXResource.setAssetId(id);
        UserSessionBase currentUserSession = ContextUtil.getCurrentUserSession();
        currentUserSession.setUserAdmin(true);
        VXResponse resp = rangerBizUtil.hasPermission(vXResource, AppConstants.XA_PERM_TYPE_UNKNOWN);
        Assertions.assertNotNull(resp);
        Assertions.assertEquals(VXResponse.STATUS_SUCCESS, resp.getStatusCode());
    }

    @Test
    public void testIsNotAdmin() {
        boolean isAdminChk = rangerBizUtil.isAdmin();
        Assertions.assertFalse(isAdminChk);
    }

    @Test
    public void testIsAdmin() {
        UserSessionBase currentUserSession = ContextUtil.getCurrentUserSession();
        currentUserSession.setUserAdmin(true);
        boolean isAdminChk = rangerBizUtil.isAdmin();
        Assertions.assertTrue(isAdminChk);
    }

    @Test
    public void testUserSessionNull_forIsAdmin() {
        RangerContextHolder.setSecurityContext(null);
        boolean isAdminChk = rangerBizUtil.isAdmin();
        Assertions.assertFalse(isAdminChk);
    }

    @Test
    public void testGetXUserId_NoUserSession() {
        RangerContextHolder.setSecurityContext(null);
        Long chk = rangerBizUtil.getXUserId();
        Assertions.assertNull(chk);
    }

    @Test
    public void testGetXUserId_NoUser() {
        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(new UserSessionBase());
        RangerContextHolder.setSecurityContext(context);
        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(id);
        xxPortalUser.setLoginId("12121");
        context.getUserSession().setXXPortalUser(xxPortalUser);

        XXUser          xxUser          = new XXUser();
        XXUserDao       xxUserDao       = Mockito.mock(XXUserDao.class);
        XXPortalUserDao xxPortalUserDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoManager.getXXPortalUser()).thenReturn(xxPortalUserDao);
        Mockito.when(xxPortalUserDao.getById(Mockito.anyLong())).thenReturn(xxPortalUser);
        Mockito.when(daoManager.getXXUser()).thenReturn(xxUserDao);
        Mockito.when(xxUserDao.findByUserName(Mockito.anyString())).thenReturn(xxUser);
        Long chk = rangerBizUtil.getXUserId();
        Mockito.verify(daoManager).getXXPortalUser();
        Mockito.verify(xxPortalUserDao).getById(Mockito.anyLong());
        Mockito.verify(daoManager).getXXUser();
        Mockito.verify(xxUserDao).findByUserName(Mockito.anyString());
        Assertions.assertNull(chk);
    }

    @Test
    public void testGetXUserId() {
        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(id);
        xxPortalUser.setLoginId("12121");
        XXUser xxUser = new XXUser();
        xxUser.setId(id);
        XXPortalUserDao       xxPortalUserDao = Mockito.mock(XXPortalUserDao.class);
        XXUserDao             xxUserDao       = Mockito.mock(XXUserDao.class);
        RangerSecurityContext context         = new RangerSecurityContext();
        UserSessionBase       userSessionBase = new UserSessionBase();
        userSessionBase.setUserAdmin(true);
        context.setUserSession(userSessionBase);
        userSessionBase.setXXPortalUser(xxPortalUser);
        RangerContextHolder.setSecurityContext(context);
        Mockito.when(daoManager.getXXPortalUser()).thenReturn(xxPortalUserDao);
        Mockito.when(xxPortalUserDao.getById(Mockito.anyLong())).thenReturn(xxPortalUser);
        Mockito.when(daoManager.getXXUser()).thenReturn(xxUserDao);
        Mockito.when(xxUserDao.findByUserName(Mockito.anyString())).thenReturn(xxUser);
        Long chk = rangerBizUtil.getXUserId();
        Mockito.verify(daoManager).getXXPortalUser();
        Mockito.verify(xxPortalUserDao).getById(Mockito.anyLong());
        Mockito.verify(daoManager).getXXUser();
        Mockito.verify(xxUserDao).findByUserName(Mockito.anyString());
        Assertions.assertEquals(chk, id);
    }

    @Test
    public void testReplaceMetaChars_PathEmpty() {
        String path    = "";
        String pathChk = rangerBizUtil.replaceMetaChars(path);
        Assertions.assertFalse(pathChk.contains("\\*"));
        Assertions.assertFalse(pathChk.contains("\\?"));
    }

    @Test
    public void testReplaceMetaChars_NoMetaChars() {
        String path    = "\\Demo\\Test";
        String pathChk = rangerBizUtil.replaceMetaChars(path);
        Assertions.assertFalse(pathChk.contains("\\*"));
        Assertions.assertFalse(pathChk.contains("\\?"));
    }

    @Test
    public void testReplaceMetaChars_PathNull() {
        String path    = null;
        String pathChk = rangerBizUtil.replaceMetaChars(path);
        Assertions.assertNull(pathChk);
    }

    @Test
    public void testReplaceMetaChars() {
        String path    = "\\Demo\\Test\\*\\?";
        String pathChk = rangerBizUtil.replaceMetaChars(path);
        Assertions.assertFalse(pathChk.contains("\\*"));
        Assertions.assertFalse(pathChk.contains("\\?"));
    }

    @Test
    public void testGeneratePublicName() {
        String firstName     = "Test123456789123456789";
        String lastName      = "Unit";
        String publicNameChk = rangerBizUtil.generatePublicName(firstName, lastName);
        Assertions.assertEquals("Test12345678... U.", publicNameChk);
    }

    @Test
    public void testGeneratePublicName_fNameLessThanMax() {
        String firstName     = "Test";
        String lastName      = "";
        String publicNameChk = rangerBizUtil.generatePublicName(firstName, lastName);
        Assertions.assertNull(publicNameChk);
    }

    @Test
    public void testGeneratePublicName_withPortalUser() {
        VXPortalUser vXPortalUser = new VXPortalUser();
        vXPortalUser.setFirstName("Test");
        vXPortalUser.setLastName(null);
        String publicNameChk = rangerBizUtil.generatePublicName(vXPortalUser, null);
        Assertions.assertNull(publicNameChk);
    }

    @Test
    public void testMatchHdfsPolicy_NoResourceName() {
        boolean bnlChk = rangerBizUtil.matchHbasePolicy(null, null, null, id, AppConstants.XA_PERM_TYPE_UNKNOWN);
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testMatchHdfsPolicy_NoResourceList() {
        boolean bnlChk = rangerBizUtil.matchHbasePolicy(resourceName, null, null, id, AppConstants.XA_PERM_TYPE_UNKNOWN);
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testMatchHdfsPolicy_NoUserId() {
        VXResponse       vXResponse    = new VXResponse();
        List<XXResource> xResourceList = new ArrayList<>();
        XXResource       xXResource    = new XXResource();
        xXResource.setId(id);
        xXResource.setName(resourceName);
        xXResource.setIsRecursive(AppConstants.BOOL_TRUE);
        xXResource.setResourceStatus(AppConstants.STATUS_ENABLED);
        xResourceList.add(xXResource);
        boolean bnlChk = rangerBizUtil.matchHbasePolicy(resourceName, xResourceList, vXResponse, null, AppConstants.XA_PERM_TYPE_UNKNOWN);
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testMatchHdfsPolicy_NoPremission() {
        VXResponse       vXResponse    = new VXResponse();
        List<XXResource> xResourceList = new ArrayList<>();
        XXResource       xXResource    = new XXResource();
        xXResource.setId(id);
        xXResource.setName(resourceName);
        xXResource.setIsRecursive(AppConstants.BOOL_TRUE);
        xXResource.setResourceStatus(AppConstants.STATUS_ENABLED);
        xResourceList.add(xXResource);
        Mockito.when(stringUtil.split(Mockito.anyString(), Mockito.anyString())).thenReturn(new String[0]);
        boolean bnlChk = rangerBizUtil.matchHbasePolicy("/*/*/*", xResourceList, vXResponse, id, AppConstants.XA_PERM_TYPE_UNKNOWN);
        Mockito.verify(stringUtil).split(Mockito.anyString(), Mockito.anyString());
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testMatchHivePolicy_NoResourceName() {
        boolean bnlChk = rangerBizUtil.matchHivePolicy(null, null, null, 0);
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testMatchHivePolicy_NoResourceList() {
        boolean bnlChk = rangerBizUtil.matchHivePolicy(resourceName, null, null, 0);
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testMatchHivePolicy_NoUserId() {
        List<XXResource> xResourceList = new ArrayList<>();
        XXResource       xXResource    = new XXResource();
        xXResource.setId(id);
        xXResource.setName(resourceName);
        xXResource.setIsRecursive(AppConstants.BOOL_TRUE);
        xXResource.setResourceStatus(AppConstants.STATUS_ENABLED);
        xResourceList.add(xXResource);
        boolean bnlChk = rangerBizUtil.matchHivePolicy(resourceName, xResourceList, null, 0);
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testMatchHivePolicy_NoPremission() {
        List<XXResource> xResourceList = new ArrayList<>();
        XXResource       xXResource    = new XXResource();
        xXResource.setId(id);
        xXResource.setName(resourceName);
        xXResource.setIsRecursive(AppConstants.BOOL_TRUE);
        xXResource.setResourceStatus(AppConstants.STATUS_ENABLED);
        xResourceList.add(xXResource);
        Mockito.when(stringUtil.split(Mockito.anyString(), Mockito.anyString())).thenReturn(new String[0]);
        boolean bnlChk = rangerBizUtil.matchHivePolicy("/*/*/*", xResourceList, id, 0);
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testMatchHivePolicy() {
        List<XXResource> xResourceList = new ArrayList<>();
        XXResource       xXResource    = new XXResource();
        xXResource.setId(5L);
        xXResource.setName(resourceName);
        xXResource.setIsRecursive(AppConstants.BOOL_TRUE);
        xXResource.setResourceStatus(AppConstants.STATUS_ENABLED);
        xResourceList.add(xXResource);
        Mockito.when(stringUtil.split(Mockito.anyString(), Mockito.anyString())).thenReturn(new String[0]);
        boolean bnlChk = rangerBizUtil.matchHivePolicy("/*/*/*", xResourceList, id, 17);
        Mockito.verify(stringUtil).split(Mockito.anyString(), Mockito.anyString());
        Assertions.assertFalse(bnlChk);
    }

    @Test
    public void testCheckUserAccessibleThrowErrorForKeyAdminAndUserRoleSysAdmin() {
        Collection<String> roleList = new ArrayList<>();
        roleList.add(RangerConstants.ROLE_SYS_ADMIN);
        Mockito.when(userMgr.getRolesByLoginId(vXUser.getName())).thenReturn(
                roleList);
        Mockito.when(vXUser.getUserRoleList()).thenReturn(roleList);

        currentUserSession.setKeyAdmin(true);
        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.when(currentUserSession.isKeyAdmin()).thenReturn(true);

        WebApplicationException webExp = new WebApplicationException();

        Mockito.when(restErrorUtil.createRESTException("Logged in user is not allowed to create/update user", MessageEnums.OPER_NO_PERMISSION)).thenReturn(webExp);

        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.checkUserAccessible(vXUser));

        Mockito.verify(restErrorUtil).createRESTException("Logged in user is not allowed to create/update user", MessageEnums.OPER_NO_PERMISSION);
    }

    @Test
    public void testCheckUserAccessibleThrowErrorForKeyAdminAndUserRoleAdminAuditor() {
        Collection<String> roleList = new ArrayList<>();
        roleList.add(RangerConstants.ROLE_ADMIN_AUDITOR);
        Mockito.when(userMgr.getRolesByLoginId(vXUser.getName())).thenReturn(roleList);
        Mockito.when(vXUser.getUserRoleList()).thenReturn(roleList);

        currentUserSession.setKeyAdmin(true);
        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.when(currentUserSession.isKeyAdmin()).thenReturn(true);

        WebApplicationException webExp = new WebApplicationException();

        Mockito.when(restErrorUtil.createRESTException("Logged in user is not allowed to create/update user", MessageEnums.OPER_NO_PERMISSION)).thenReturn(webExp);

        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.checkUserAccessible(vXUser));

        Mockito.verify(restErrorUtil).createRESTException("Logged in user is not allowed to create/update user", MessageEnums.OPER_NO_PERMISSION);
    }

    @Test
    public void testCheckUserAccessibleSuccessForKeyAdmin() {
        Collection<String> roleList = new ArrayList<>();
        roleList.add(RangerConstants.ROLE_KEY_ADMIN);
        roleList.add(RangerConstants.ROLE_KEY_ADMIN_AUDITOR);
        Mockito.when(userMgr.getRolesByLoginId(vXUser.getName())).thenReturn(roleList);
        Mockito.when(vXUser.getUserRoleList()).thenReturn(roleList);

        currentUserSession.setKeyAdmin(true);

        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.when(currentUserSession.isKeyAdmin()).thenReturn(true);

        boolean result = rangerBizUtil.checkUserAccessible(vXUser);
        Assertions.assertTrue(result);
    }

    @Test
    public void testCheckUserAccessibleThrowErrorForAdminAndUserRoleKeyAdmin() {
        Collection<String> roleList = new ArrayList<>();
        roleList.add(RangerConstants.ROLE_KEY_ADMIN);
        Mockito.when(userMgr.getRolesByLoginId(vXUser.getName())).thenReturn(
                roleList);
        Mockito.when(vXUser.getUserRoleList()).thenReturn(roleList);

        currentUserSession.setUserAdmin(true);

        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.when(currentUserSession.isUserAdmin()).thenReturn(true);

        WebApplicationException webExp = new WebApplicationException();

        Mockito.when(restErrorUtil.createRESTException("Logged in user is not allowed to create/update user", MessageEnums.OPER_NO_PERMISSION)).thenReturn(webExp);

        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.checkUserAccessible(vXUser));

        Mockito.verify(restErrorUtil).createRESTException("Logged in user is not allowed to create/update user", MessageEnums.OPER_NO_PERMISSION);
    }

    @Test
    public void testCheckUserAccessibleThrowErrorForAdminAndUserRoleKeyAdminAuditor() {
        Collection<String> roleList = new ArrayList<>();
        roleList.add(RangerConstants.ROLE_KEY_ADMIN_AUDITOR);
        Mockito.when(userMgr.getRolesByLoginId(vXUser.getName())).thenReturn(roleList);
        Mockito.when(vXUser.getUserRoleList()).thenReturn(roleList);

        currentUserSession.setUserAdmin(true);

        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.when(currentUserSession.isUserAdmin()).thenReturn(true);

        WebApplicationException webExp = new WebApplicationException();

        Mockito.when(restErrorUtil.createRESTException("Logged in user is not allowed to create/update user", MessageEnums.OPER_NO_PERMISSION)).thenReturn(webExp);

        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.checkUserAccessible(vXUser));

        Mockito.verify(restErrorUtil).createRESTException("Logged in user is not allowed to create/update user", MessageEnums.OPER_NO_PERMISSION);
    }

    @Test
    public void testCheckUserAccessibleSuccessForAdmin() {
        Collection<String> roleList = new ArrayList<>();
        roleList.add(RangerConstants.ROLE_SYS_ADMIN);
        Mockito.when(userMgr.getRolesByLoginId(vXUser.getName())).thenReturn(roleList);
        Mockito.when(vXUser.getUserRoleList()).thenReturn(roleList);

        currentUserSession.setUserAdmin(true);

        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.when(currentUserSession.isUserAdmin()).thenReturn(true);

        boolean result = rangerBizUtil.checkUserAccessible(vXUser);
        Assertions.assertTrue(result);
    }

    @Test
    public void testBlockAuditorRoleUserThrowsErrorForAuditKeyAdmin() {
        RangerBizUtil rangerBizUtilMock = Mockito.mock(RangerBizUtil.class);
        vXResponse.setStatusCode(HttpServletResponse.SC_UNAUTHORIZED);
        vXResponse.setMsgDesc("Operation denied. LoggedInUser=1 ,isn't permitted to perform the action.");

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(1L);

        currentUserSession.setAuditKeyAdmin(true);

        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.doThrow(new WebApplicationException()).when(rangerBizUtilMock).blockAuditorRoleUser();
        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtilMock.blockAuditorRoleUser());
    }

    @Test
    public void testBlockAuditorRoleUserThrowsErrorForAuditUserAdmin() {
        RangerBizUtil rangerBizUtilMock = Mockito.mock(RangerBizUtil.class);

        vXResponse.setStatusCode(HttpServletResponse.SC_UNAUTHORIZED);
        vXResponse.setMsgDesc("Operation denied. LoggedInUser=1 ,isn't permitted to perform the action.");

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(1L);

        currentUserSession.setAuditKeyAdmin(true);

        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.doThrow(new WebApplicationException()).when(rangerBizUtilMock).blockAuditorRoleUser();

        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtilMock.blockAuditorRoleUser());
    }

    @Test
    public void testBlockAuditorRoleUserSuccess() {
        RangerBizUtil rangerBizUtilMock = Mockito.mock(RangerBizUtil.class);

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(1L);

        currentUserSession.setUserAdmin(true);

        RangerSecurityContext context = new RangerSecurityContext();
        context.setUserSession(currentUserSession);
        RangerContextHolder.setSecurityContext(context);

        Mockito.doNothing().when(rangerBizUtilMock).blockAuditorRoleUser();

        rangerBizUtilMock.blockAuditorRoleUser();
        Mockito.verify(rangerBizUtilMock).blockAuditorRoleUser();
    }

    @Test
    public void testIsRecursiveWildCardMatch_and_NonRecursive_and_ComparePaths() {
        String wc = "/a/b/*";
        Assertions.assertTrue(rangerBizUtil.isRecursiveWildCardMatch("/a/b/c", wc));
        Assertions.assertFalse(rangerBizUtil.isRecursiveWildCardMatch("/a/c", wc));

        Assertions.assertTrue(rangerBizUtil.nonRecursiveWildCardMatch("/a/b", "/a/*"));
        Assertions.assertFalse(rangerBizUtil.nonRecursiveWildCardMatch("/a/b/c", "/a/*"));

        Assertions.assertTrue(rangerBizUtil.comparePathsForExactMatch("/a/b", "/a/b"));
        Assertions.assertFalse(rangerBizUtil.comparePathsForExactMatch("/a/b", "/a/bc"));
    }

    @Test
    public void testGetResorceTypeParentHirearchy() {
        List<Integer> hdfs = rangerBizUtil.getResorceTypeParentHirearchy(AppConstants.RESOURCE_PATH, AppConstants.ASSET_HDFS);
        Assertions.assertEquals(1, hdfs.size());

        List<Integer> hiveTbl = rangerBizUtil.getResorceTypeParentHirearchy(AppConstants.RESOURCE_TABLE, AppConstants.ASSET_HIVE);
        Assertions.assertTrue(hiveTbl.contains(AppConstants.RESOURCE_DB));
        Assertions.assertTrue(hiveTbl.contains(AppConstants.RESOURCE_TABLE));

        List<Integer> hiveCol = rangerBizUtil.getResorceTypeParentHirearchy(AppConstants.RESOURCE_COLUMN, AppConstants.ASSET_HIVE);
        Assertions.assertTrue(hiveCol.contains(AppConstants.RESOURCE_TABLE));
        Assertions.assertTrue(hiveCol.contains(AppConstants.RESOURCE_COLUMN));
    }

    @Test
    public void testRemoveEmptyStringsAndTrimAll() {
        List<String> list = new ArrayList<>();
        list.add(" a ");
        list.add(" ");
        rangerBizUtil.removeEmptyStrings(list);
        Assertions.assertEquals(1, list.size());
        Assertions.assertEquals("a", list.get(0));
    }

    @Test
    public void testAuditDBTypeGetterSetter() {
        rangerBizUtil.setAuditDBType("solr");
        Assertions.assertEquals("solr", rangerBizUtil.getAuditDBType());
    }

    @Test
    public void testCreateTrxLog_Writes() throws Exception {
        XXTrxLogV2Dao trxDao = Mockito.mock(XXTrxLogV2Dao.class);
        Mockito.when(daoManager.getXXTrxLogV2()).thenReturn(trxDao);
        // set guidUtil via reflection
        Field f = RangerBizUtil.class.getDeclaredField("guidUtil");
        f.setAccessible(true);
        f.set(rangerBizUtil, new GUIDUtil());

        List<XXTrxLogV2> list = new ArrayList<>();
        list.add(new XXTrxLogV2());
        // user session already set in @Before setup()
        rangerBizUtil.createTrxLog(list);
        Mockito.verify(trxDao, Mockito.atLeastOnce()).create(Mockito.any(XXTrxLogV2.class));
    }

    @Test
    public void testCheckAdminAccess_ThrowsWhenNoSession() {
        VXResponse resp = new VXResponse();
        WebApplicationException wae = new WebApplicationException();
        Mockito.when(restErrorUtil.generateRESTException(Mockito.any(VXResponse.class))).thenReturn(wae);
        RangerContextHolder.setSecurityContext(null);
        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.checkAdminAccess());
    }

    @Test
    public void testUserAllowedAndConfigParameterChecks() {
        RangerService svc = new RangerService();
        Map<String, String> cfg = new HashMap<>();
        cfg.put("allow", "*,bob");
        cfg.put(ServiceDBStore.SERVICE_ADMIN_USERS, "bob,carol");
        cfg.put(ServiceDBStore.SERVICE_ADMIN_GROUPS, "public,dev");
        svc.setConfigs(cfg);

        UserSessionBase usb = ContextUtil.getCurrentUserSession();
        XXPortalUser pu = new XXPortalUser();
        pu.setLoginId("alice");
        usb.setXXPortalUser(pu);

        Assertions.assertTrue(rangerBizUtil.isUserInConfigParameter(svc, "allow", "alice"));
        Assertions.assertTrue(rangerBizUtil.isUserAllowed(svc, "allow"));

        Set<String> groups = new HashSet<>();
        groups.add(RangerConstants.GROUP_PUBLIC);
        Assertions.assertTrue(rangerBizUtil.isAnyGroupInConfigParameter(svc, ServiceDBStore.SERVICE_ADMIN_GROUPS, groups));
    }

    @Test
    public void testAreAllEqual_Varargs() {
        Assertions.assertTrue(RangerBizUtil.areAllEqual(5, 5, 5));
        Assertions.assertFalse(RangerBizUtil.areAllEqual(5, 5, 4));
    }

    @Test
    public void testBulkMode_SetAndGet() {
        // default may be false
        boolean initial = RangerBizUtil.isBulkMode();
        Assertions.assertEquals(false, RangerBizUtil.setBulkMode(false));
        // restore initial to avoid side-effects
        RangerBizUtil.setBulkMode(initial);
    }

    @Test
    public void testHasAdminPermissions_NoSession_Throws() {
        WebApplicationException wae = new WebApplicationException();
        Mockito.when(restErrorUtil.createRESTException(Mockito.anyString(), Mockito.any(MessageEnums.class))).thenReturn(wae);
        RangerContextHolder.setSecurityContext(null);
        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.hasAdminPermissions("Object"));
    }

    @Test
    public void testBulkModeOnlyFlushAndClear_CallsFlushAndClear() {
        XXDBBaseDao baseDao = Mockito.mock(XXDBBaseDao.class);
        Mockito.when(daoManager.getXXDBBase()).thenReturn(baseDao);
        rangerBizUtil.bulkModeOnlyFlushAndClear();
        Mockito.verify(baseDao, Mockito.atLeastOnce()).flush();
        Mockito.verify(baseDao, Mockito.atLeastOnce()).clear();
    }

    @Test
    public void testMapStringListToVStringList() {
        List<String> input = Arrays.asList("a", "b");
        VXStringList out = rangerBizUtil.mapStringListToVStringList(input);
        Assertions.assertNotNull(out);
        Assertions.assertEquals(2, out.getList().size());
        Assertions.assertEquals("a", out.getList().get(0).getValue());
        Assertions.assertNull(rangerBizUtil.mapStringListToVStringList(null));
    }

    @Test
    public void testGetCurrentUserLoginId_andAuditFlags() {
        String login = rangerBizUtil.getCurrentUserLoginId();
        Assertions.assertNull(login);

        XXPortalUser pu = new XXPortalUser();
        pu.setId(101L);
        pu.setLoginId("u1");
        RangerContextHolder.getSecurityContext().getUserSession().setXXPortalUser(pu);
        Assertions.assertEquals("u1", rangerBizUtil.getCurrentUserLoginId());

        Assertions.assertFalse(rangerBizUtil.isAuditAdmin());
        RangerContextHolder.getSecurityContext().getUserSession().setAuditUserAdmin(true);
        Assertions.assertTrue(rangerBizUtil.isAuditAdmin());

        Assertions.assertFalse(rangerBizUtil.isKeyAdmin());
        RangerContextHolder.getSecurityContext().getUserSession().setKeyAdmin(true);
        Assertions.assertTrue(rangerBizUtil.isKeyAdmin());
    }

    @Test
    public void testHasAccess_ForServiceDefAndService() {
        // ServiceDef: KMS requires keyAdmin or auditKeyAdmin
        XXServiceDef sdKms = new XXServiceDef();
        sdKms.setImplclassname(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME);
        RangerContextHolder.getSecurityContext().getUserSession().setKeyAdmin(true);
        Assertions.assertTrue(rangerBizUtil.hasAccess(sdKms, null));

        // ServiceDef: non-KMS allows sysadmin/auditor/user
        XXServiceDef sdOther = new XXServiceDef();
        sdOther.setImplclassname("some.impl");
        RangerContextHolder.getSecurityContext().getUserSession().setKeyAdmin(false);
        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(true);
        Assertions.assertTrue(rangerBizUtil.hasAccess(sdOther, null));
        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(false);
        RangerContextHolder.getSecurityContext().getUserSession().setAuditUserAdmin(true);
        Assertions.assertTrue(rangerBizUtil.hasAccess(sdOther, null));

        // Service: KMS requires keyAdmin or auditKeyAdmin when not sysadmin/auditor
        XXService svc = new XXService();
        svc.setType(123L);
        XXServiceDefDao sdDao = Mockito.mock(XXServiceDefDao.class);
        XXServiceDef sdForSvc = new XXServiceDef();
        sdForSvc.setImplclassname(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME);
        Mockito.when(daoManager.getXXServiceDef()).thenReturn(sdDao);
        Mockito.when(sdDao.getById(Mockito.eq(123L))).thenReturn(sdForSvc);
        RangerContextHolder.getSecurityContext().getUserSession().setAuditUserAdmin(false);
        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(false);
        RangerContextHolder.getSecurityContext().getUserSession().setKeyAdmin(true);
        Assertions.assertTrue(rangerBizUtil.hasAccess(svc, null));

        // Service: non-KMS requires ROLE_USER when not sysadmin/auditor
        sdForSvc.setImplclassname("some.impl");
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_USER);
        RangerContextHolder.getSecurityContext().getUserSession().setUserRoleList(roles);
        Assertions.assertTrue(rangerBizUtil.hasAccess(svc, null));
    }

    @Test
    public void testHasKMSPermissions_ThrowsForKeyAdminOnNonKMS_andSysAdminOnKMSDef() {
        WebApplicationException wae = new WebApplicationException();
        Mockito.when(restErrorUtil.createRESTException(Mockito.anyString(), Mockito.any(MessageEnums.class))).thenReturn(wae);

        // KeyAdmin on non-KMS object
        RangerContextHolder.getSecurityContext().getUserSession().setKeyAdmin(true);
        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.hasKMSPermissions("Service", "not.kms"));
    }

    @Test
    public void testIsSSOEnabled_andGetDBVersion_andUserAdminChecks() throws Exception {
        // session exists, SSO from session value
        RangerContextHolder.getSecurityContext().getUserSession().setSSOEnabled(Boolean.TRUE);
        Assertions.assertTrue(rangerBizUtil.isSSOEnabled());

        // DB version path
        XXUserDao xxUserDao = Mockito.mock(XXUserDao.class);
        Mockito.when(daoManager.getXXUser()).thenReturn(xxUserDao);
        Mockito.when(xxUserDao.getDBVersion()).thenReturn("v1");
        Assertions.assertEquals("v1", rangerBizUtil.getDBVersion());

        // isUserRangerAdmin
        XUserService xUserService = Mockito.mock(XUserService.class);
        Collection<String> adminRoles = new ArrayList<>();
        adminRoles.add(RangerConstants.ROLE_ADMIN);
        VXUser vx = new VXUser();
        vx.setUserRoleList(adminRoles);
        Field f = RangerBizUtil.class.getDeclaredField("xUserService");
        f.setAccessible(true);
        f.set(rangerBizUtil, xUserService);
        Mockito.when(xUserService.getXUserByUserName("alice")).thenReturn(vx);
        Assertions.assertTrue(rangerBizUtil.isUserRangerAdmin("alice"));
    }

    @Test
    public void testIsUserServiceAdmin_UsersConfig() {
        RangerService svc = new RangerService();
        Map<String, String> cfg = new HashMap<>();
        cfg.put(ServiceDBStore.SERVICE_ADMIN_USERS, "bob,carol");
        svc.setConfigs(cfg);
        Assertions.assertTrue(rangerBizUtil.isUserServiceAdmin(svc, "bob"));
        Assertions.assertFalse(rangerBizUtil.isUserServiceAdmin(svc, "alice"));
    }

    @Test
    public void testGetCreatePrincipalsIfAbsent_trueWhenSetInOpContext() {
        RangerAdminOpContext opCtx = RangerContextHolder.getOrCreateOpContext();
        opCtx.setCreatePrincipalsIfAbsent(true);
        Assertions.assertTrue(rangerBizUtil.getCreatePrincipalsIfAbsent());
    }

    @Test
    public void testGetPublicGroupId_andIsGroupInList() {
        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoManager.getXXGroup()).thenReturn(groupDao);
        XXGroup grp = new XXGroup();
        grp.setId(99L);
        Mockito.when(groupDao.findByGroupName(RangerConstants.GROUP_PUBLIC)).thenReturn(grp);
        Assertions.assertEquals(99L, rangerBizUtil.getPublicGroupId());

        List<XXGroup> list = new ArrayList<>();
        list.add(grp);
        Assertions.assertTrue(rangerBizUtil.isGroupInList(99L, list));
        Assertions.assertFalse(rangerBizUtil.isGroupInList(100L, list));
    }

    @Test
    public void testFailUnauthenticatedChecks_doNotThrowWhenSecurityDisabled() {
        Assertions.assertDoesNotThrow(() -> rangerBizUtil.failUnauthenticatedIfNotAllowed());
        Assertions.assertDoesNotThrow(() -> rangerBizUtil.failUnauthenticatedDownloadIfNotAllowed());
    }

    @Test
    public void testHasModuleAccess_forNonAdminAndAdmin() {
        UserSessionBase.RangerUserPermission perm = new UserSessionBase.RangerUserPermission();
        CopyOnWriteArraySet<String> perms = new CopyOnWriteArraySet<>();
        perms.add("moduleA");
        perm.setUserPermissions(perms);
        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(false);
        RangerContextHolder.getSecurityContext().getUserSession().setAuditUserAdmin(false);
        RangerContextHolder.getSecurityContext().getUserSession().setRangerUserPermission(perm);
        Assertions.assertTrue(rangerBizUtil.hasModuleAccess("moduleA"));
        Assertions.assertFalse(rangerBizUtil.hasModuleAccess("moduleB"));

        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(true);
        Assertions.assertTrue(rangerBizUtil.hasModuleAccess("anything"));
    }

    @Test
    public void testIsAuditKeyAdminFlag() {
        RangerContextHolder.getSecurityContext().getUserSession().setAuditKeyAdmin(true);
        Assertions.assertTrue(rangerBizUtil.isAuditKeyAdmin());
        RangerContextHolder.getSecurityContext().getUserSession().setAuditKeyAdmin(false);
        Assertions.assertFalse(rangerBizUtil.isAuditKeyAdmin());
    }

    @Test
    public void testHasAccess_RangerServiceHeaderInfo() {
        RangerServiceHeaderInfo hdr = new RangerServiceHeaderInfo();
        hdr.setType("hdfs");
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_USER);
        RangerContextHolder.getSecurityContext().getUserSession().setUserRoleList(roles);
        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(false);
        RangerContextHolder.getSecurityContext().getUserSession().setAuditUserAdmin(false);
        Assertions.assertTrue(rangerBizUtil.hasAccess(null, hdr));

        hdr.setType(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KMS_NAME);
        RangerContextHolder.getSecurityContext().getUserSession().setKeyAdmin(false);
        Assertions.assertFalse(rangerBizUtil.hasAccess(null, hdr));
        RangerContextHolder.getSecurityContext().getUserSession().setAuditKeyAdmin(true);
        Assertions.assertTrue(rangerBizUtil.hasAccess(null, hdr));
    }

    @Test
    public void testHasKMSPermissions_ThrowsForSysAdminOnServiceDefKMS() {
        WebApplicationException wae = new WebApplicationException();
        Mockito.when(restErrorUtil.createRESTException(Mockito.anyString(), Mockito.any(MessageEnums.class))).thenReturn(wae);
        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(true);
        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.hasKMSPermissions("Service-Def", EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME));
    }

    @Test
    public void testIsUserAllowedForGrantRevokeWrapper() {
        RangerService svc = new RangerService();
        Map<String, String> cfg = new HashMap<>();
        cfg.put(ServiceREST.Allowed_User_List_For_Grant_Revoke, "alice");
        svc.setConfigs(cfg);
        Assertions.assertTrue(rangerBizUtil.isUserAllowedForGrantRevoke(svc, "alice"));
        Assertions.assertFalse(rangerBizUtil.isUserAllowedForGrantRevoke(svc, "bob"));
    }

    @Test
    public void testBlockAuditorRoleUser_NoExceptionForNormalUser() {
        RangerContextHolder.getSecurityContext().getUserSession().setAuditKeyAdmin(false);
        RangerContextHolder.getSecurityContext().getUserSession().setAuditUserAdmin(false);
        Assertions.assertDoesNotThrow(() -> rangerBizUtil.blockAuditorRoleUser());
    }

    @Test
    public void testIsGdsHelpers() {
        XXServiceDef def = new XXServiceDef();
        def.setName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_GDS_NAME);
        Assertions.assertTrue(rangerBizUtil.isGdsServiceDef(def));
        def.setName("hdfs");
        Assertions.assertFalse(rangerBizUtil.isGdsServiceDef(def));

        XXService svc = new XXService();
        svc.setType(EmbeddedServiceDefsUtil.instance().getGdsServiceDefId());
        Assertions.assertTrue(rangerBizUtil.isGdsService(svc));
        svc.setType(1L);
        Assertions.assertFalse(rangerBizUtil.isGdsService(svc));
    }

    // Additional coverage for zero-covered methods
    @Test
    public void testCheckSystemAdminAccess_allowsAndDenies() {
        // allow when userAdmin
        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(true);
        Assertions.assertDoesNotThrow(() -> rangerBizUtil.checkSystemAdminAccess());
        // deny otherwise
        RangerContextHolder.getSecurityContext().getUserSession().setUserAdmin(false);
        WebApplicationException wae = new WebApplicationException();
        Mockito.when(restErrorUtil.create403RESTException(Mockito.anyString())).thenReturn(wae);
        Assertions.assertThrows(WebApplicationException.class, () -> rangerBizUtil.checkSystemAdminAccess());
    }

    private void setupSessionAndUser(long xUserId, String loginId) {
        XXPortalUser portalUser = new XXPortalUser();
        portalUser.setId(1L);
        portalUser.setLoginId(loginId);
        RangerContextHolder.getSecurityContext().getUserSession().setXXPortalUser(portalUser);
    }

    private void setupHasPermissionUserDAOs(long xUserId, String loginId) {
        XXPortalUser portalUser = RangerContextHolder.getSecurityContext().getUserSession().getXXPortalUser();
        if (portalUser == null) {
            portalUser = new XXPortalUser();
            portalUser.setId(1L);
            portalUser.setLoginId(loginId);
            RangerContextHolder.getSecurityContext().getUserSession().setXXPortalUser(portalUser);
        }
        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        XXUser xUser = new XXUser();
        xUser.setId(xUserId);
        Mockito.when(daoManager.getXXPortalUser()).thenReturn(portalDao);
        Mockito.when(portalDao.getById(Mockito.anyLong())).thenReturn(portalUser);
        Mockito.when(daoManager.getXXUser()).thenReturn(userDao);
        Mockito.when(userDao.findByUserName(Mockito.eq(loginId))).thenReturn(xUser);
        Mockito.when(daoManager.getXXGroup()).thenReturn(groupDao);
        Mockito.when(groupDao.findByUserId(Mockito.eq(xUserId))).thenReturn(new ArrayList<>());
    }

    private void ensureGroupDaoForUser(long xUserId) {
        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoManager.getXXGroup()).thenReturn(groupDao);
        Mockito.when(groupDao.findByUserId(Mockito.eq(xUserId))).thenReturn(new ArrayList<>());
    }

    private void stubStringSplitToUseJavaImpl() {
        try {
            Field f = RangerBizUtil.class.getDeclaredField("stringUtil");
            f.setAccessible(true);
            f.set(rangerBizUtil, new StringUtil());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void allowUserPermissionForResource(long resourceId, long xUserId, int permission) {
        XXPermMapDao permDao = Mockito.mock(XXPermMapDao.class);
        XXPermMap perm = new XXPermMap();
        perm.setPermType(permission);
        perm.setPermFor(AppConstants.XA_PERM_FOR_USER);
        perm.setUserId(xUserId);
        List<XXPermMap> maps = new ArrayList<>();
        maps.add(perm);
        Mockito.when(daoManager.getXXPermMap()).thenReturn(permDao);
        Mockito.when(permDao.findByResourceId(Mockito.eq(resourceId))).thenReturn(maps);
    }

    private void setupAssetAndResources(long assetId, int assetType, List<XXResource> resources) {
        XXResourceDao resDao = Mockito.mock(XXResourceDao.class);
        XXAssetDao assetDao = Mockito.mock(XXAssetDao.class);
        XXAsset asset = new XXAsset();
        asset.setId(assetId);
        asset.setAssetType(assetType);
        Mockito.when(daoManager.getXXResource()).thenReturn(resDao);
        Mockito.when(resDao.findByAssetIdAndResourceStatus(Mockito.eq(assetId), Mockito.anyInt())).thenReturn(resources);
        Mockito.when(daoManager.getXXAsset()).thenReturn(assetDao);
        Mockito.when(assetDao.getById(Mockito.eq(assetId))).thenReturn(asset);
    }

    @Test
    public void testMatchHdfsPolicy_viaHasPermission_success() {
        long assetId = 200L;
        long resourceId = 300L;
        int permission = AppConstants.XA_PERM_TYPE_UNKNOWN;
        setupSessionAndUser(111L, "user1");
        setupHasPermissionUserDAOs(111L, "user1");
        stubStringSplitToUseJavaImpl();

        XXResource xRes = new XXResource();
        xRes.setId(resourceId);
        xRes.setName("/a/b/*");
        xRes.setIsRecursive(AppConstants.BOOL_TRUE);
        xRes.setResourceStatus(AppConstants.STATUS_ENABLED);
        List<XXResource> resList = new ArrayList<>();
        resList.add(xRes);
        setupAssetAndResources(assetId, AppConstants.ASSET_HDFS, resList);
        allowUserPermissionForResource(resourceId, 111L, permission);

        VXResource req = new VXResource();
        req.setAssetId(assetId);
        req.setName("/a/b/c");
        VXResponse out = rangerBizUtil.hasPermission(req, permission);
        Assertions.assertEquals(VXResponse.STATUS_SUCCESS, out.getStatusCode());
    }

    @Test
    public void testMatchKnoxPolicy_viaHasPermission_success() {
        long assetId = 201L;
        long resourceId = 301L;
        int permission = AppConstants.XA_PERM_TYPE_UNKNOWN;
        setupSessionAndUser(112L, "user2");
        setupHasPermissionUserDAOs(112L, "user2");
        stubStringSplitToUseJavaImpl();

        XXResource xRes = new XXResource();
        xRes.setId(resourceId);
        xRes.setTopologies("topo");
        xRes.setServices("svc1");
        xRes.setResourceStatus(AppConstants.STATUS_ENABLED);
        List<XXResource> resList = new ArrayList<>();
        resList.add(xRes);
        setupAssetAndResources(assetId, AppConstants.ASSET_KNOX, resList);
        allowUserPermissionForResource(resourceId, 112L, permission);

        VXResource req = new VXResource();
        req.setAssetId(assetId);
        // topology/service
        req.setName("topo/svc1");
        VXResponse out = rangerBizUtil.hasPermission(req, permission);
        Assertions.assertEquals(VXResponse.STATUS_SUCCESS, out.getStatusCode());
    }

    @Test
    public void testMatchStormPolicy_viaHasPermission_success() {
        long assetId = 202L;
        long resourceId = 302L;
        int permission = AppConstants.XA_PERM_TYPE_UNKNOWN;
        setupSessionAndUser(113L, "user3");
        setupHasPermissionUserDAOs(113L, "user3");
        stubStringSplitToUseJavaImpl();

        XXResource xRes = new XXResource();
        xRes.setId(resourceId);
        xRes.setTopologies("topo");
        xRes.setResourceStatus(AppConstants.STATUS_ENABLED);
        List<XXResource> resList = new ArrayList<>();
        resList.add(xRes);
        setupAssetAndResources(assetId, AppConstants.ASSET_STORM, resList);
        allowUserPermissionForResource(resourceId, 113L, permission);

        VXResource req = new VXResource();
        req.setAssetId(assetId);
        req.setName("topo");
        VXResponse out = rangerBizUtil.hasPermission(req, permission);
        Assertions.assertEquals(VXResponse.STATUS_SUCCESS, out.getStatusCode());
    }

    @Test
    public void testMatchHivePolicy_true() {
        long resourceId = 401L;
        int permission = AppConstants.XA_PERM_TYPE_UNKNOWN;
        setupSessionAndUser(114L, "user4");
        stubStringSplitToUseJavaImpl();
        ensureGroupDaoForUser(114L);

        XXResource xRes = new XXResource();
        xRes.setId(resourceId);
        xRes.setDatabases("db");
        xRes.setTables("tbl");
        xRes.setColumns("col");
        xRes.setResourceStatus(AppConstants.STATUS_ENABLED);
        List<XXResource> resList = new ArrayList<>();
        resList.add(xRes);
        allowUserPermissionForResource(resourceId, 114L, permission);

        Assertions.assertTrue(rangerBizUtil.matchHivePolicy("db/tbl/col", resList, 114L, permission, 0, 0, false));
    }

    @Test
    public void testMatchHbasePolicy_true() {
        long resourceId = 402L;
        int permission = AppConstants.XA_PERM_TYPE_UNKNOWN;
        setupSessionAndUser(115L, "user5");
        stubStringSplitToUseJavaImpl();
        ensureGroupDaoForUser(115L);

        XXResource xRes = new XXResource();
        xRes.setId(resourceId);
        xRes.setTables("t");
        xRes.setColumnFamilies("f");
        xRes.setColumns("c");
        xRes.setResourceStatus(AppConstants.STATUS_ENABLED);
        List<XXResource> resList = new ArrayList<>();
        resList.add(xRes);
        allowUserPermissionForResource(resourceId, 115L, permission);

        VXResponse vXResponse = new VXResponse();
        Assertions.assertTrue(rangerBizUtil.matchHbasePolicy("t/f/c", resList, vXResponse, 115L, permission));
    }
}
