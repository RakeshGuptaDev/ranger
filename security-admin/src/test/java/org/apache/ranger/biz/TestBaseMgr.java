/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.biz;

import org.apache.ranger.common.MessageEnums;
import org.apache.ranger.common.RESTErrorUtil;
import org.apache.ranger.common.db.BaseDao;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.entity.XXDBBase;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.ws.rs.WebApplicationException;

import java.lang.reflect.Field;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
* @generated by Cursor
* @description <Unit Test for TestBaseMgr class>
*/
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestBaseMgr {
    private static class TestableBaseMgr extends BaseMgr { }

    private static void setField(Object target, String fieldName, Object value) throws Exception {
        Field f = BaseMgr.class.getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(target, value);
    }

    @Test
    public void testGetDaoManager() throws Exception {
        TestableBaseMgr mgr = new TestableBaseMgr();
        RangerDaoManager daoManager = mock(RangerDaoManager.class);
        setField(mgr, "daoManager", daoManager);

        Assertions.assertSame(daoManager, mgr.getDaoManager());
    }

    @Test
    public void testDeleteEntity_entityExists_success() throws Exception {
        TestableBaseMgr mgr = new TestableBaseMgr();
        RESTErrorUtil restErrorUtil = mock(RESTErrorUtil.class);
        setField(mgr, "restErrorUtil", restErrorUtil);

        @SuppressWarnings("unchecked")
        BaseDao<XXDBBase> baseDao = (BaseDao<XXDBBase>) mock(BaseDao.class);
        XXDBBase entity = mock(XXDBBase.class);
        when(baseDao.getById(1L)).thenReturn(entity);

        mgr.deleteEntity(baseDao, 1L, "Entity");

        verify(baseDao, times(1)).remove(1L);
    }

    @Test
    public void testDeleteEntity_entityMissing_noop() throws Exception {
        TestableBaseMgr mgr = new TestableBaseMgr();
        RESTErrorUtil restErrorUtil = mock(RESTErrorUtil.class);
        setField(mgr, "restErrorUtil", restErrorUtil);

        @SuppressWarnings("unchecked")
        BaseDao<XXDBBase> baseDao = (BaseDao<XXDBBase>) mock(BaseDao.class);
        when(baseDao.getById(2L)).thenReturn(null);

        mgr.deleteEntity(baseDao, 2L, "Entity");

        verify(baseDao, times(0)).remove(2L);
    }

    @Test
    public void testDeleteEntity_removeThrows_wrapsInRESTException() throws Exception {
        TestableBaseMgr mgr = new TestableBaseMgr();
        RESTErrorUtil restErrorUtil = mock(RESTErrorUtil.class);
        setField(mgr, "restErrorUtil", restErrorUtil);

        WebApplicationException expected = new WebApplicationException();
        when(restErrorUtil.createRESTException(eq("This Entity can't be deleted"), eq(MessageEnums.OPER_NOT_ALLOWED_FOR_STATE), eq(3L), eq(null), any(String.class)))
                .thenReturn(expected);

        @SuppressWarnings("unchecked")
        BaseDao<XXDBBase> baseDao = (BaseDao<XXDBBase>) mock(BaseDao.class);
        XXDBBase entity = mock(XXDBBase.class);
        when(baseDao.getById(3L)).thenReturn(entity);
        doThrow(new RuntimeException("db error")).when(baseDao).remove(3L);

        WebApplicationException thrown = Assertions.assertThrows(WebApplicationException.class, () -> mgr.deleteEntity(baseDao, 3L, "Entity"));
        Assertions.assertSame(expected, thrown);
    }

    @Test
    public void testValidateClassType_delegatesToRestErrorUtil() throws Exception {
        TestableBaseMgr mgr = new TestableBaseMgr();
        RESTErrorUtil restErrorUtil = mock(RESTErrorUtil.class);
        setField(mgr, "restErrorUtil", restErrorUtil);

        // call with arbitrary value; verify validateMinMax invoked with min=1 and fieldName "objectClassType"
        // max value is implementation detail; use anyInt() matcher
        mgr.validateClassType(5);

        verify(restErrorUtil, times(1)).validateMinMax(eq(5), eq(1), anyInt(), eq("Invalid classType"), eq(null), eq("objectClassType"));
    }
}
