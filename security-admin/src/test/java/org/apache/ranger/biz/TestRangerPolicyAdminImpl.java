/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.biz;

import org.apache.ranger.authorization.hadoop.config.RangerPluginConfig;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItem;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItemAccess;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyResource;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerAccessTypeDef;
import org.apache.ranger.plugin.policyengine.PolicyEngine;
import org.apache.ranger.plugin.policyengine.RangerAccessRequest;
import org.apache.ranger.plugin.policyengine.RangerAccessRequestImpl;
import org.apache.ranger.plugin.policyengine.RangerAccessResource;
import org.apache.ranger.plugin.policyengine.RangerPluginContext;
import org.apache.ranger.plugin.policyengine.RangerPolicyEngine;
import org.apache.ranger.plugin.policyengine.RangerPolicyRepository;
import org.apache.ranger.plugin.policyevaluator.RangerPolicyEvaluator;
import org.apache.ranger.plugin.policyevaluator.RangerPolicyEvaluator.RangerPolicyResourceEvaluator;
import org.apache.ranger.plugin.policyresourcematcher.RangerPolicyResourceMatcher;
import org.apache.ranger.plugin.service.RangerAuthContext;
import org.apache.ranger.plugin.store.ServiceStore;
import org.apache.ranger.plugin.util.GrantRevokeRequest;
import org.apache.ranger.plugin.util.RangerReadWriteLock.RangerLock;
import org.apache.ranger.plugin.util.ServicePolicies;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNotSame;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.ArgumentMatchers.anyMap;
import static org.mockito.ArgumentMatchers.anySet;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description <Unit Test for TestRangerPolicyAdminImpl class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerPolicyAdminImpl {
    @Mock
    PolicyEngine policyEngine;
    @Mock
    RangerPolicyRepository policyRepository;
    @Mock
    RangerPolicyRepository tagPolicyRepository;
    @Mock
    RangerPluginContext pluginContext;
    @Mock
    RangerAuthContext authContext;
    @Mock
    ServiceDBStore serviceDBStore;

    @Test
    public void testGetPolicyAdmin_staticFactory_nullsAndSameEngine() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        assertNull(RangerPolicyAdminImpl.getPolicyAdmin(null, null));
        ServicePolicies sp = new ServicePolicies();
        // cloneWithDelta returns same engine -> same admin instance
        when(policyEngine.cloneWithDelta(sp)).thenReturn(policyEngine);
        RangerPolicyAdmin admin1 = RangerPolicyAdminImpl.getPolicyAdmin(admin, sp);
        assertSame(admin, admin1);
    }

    @Test
    public void testGetPolicyAdmin_staticFactory_newEngine() throws Exception {
        Constructor<RangerPolicyAdminImpl> ctor = RangerPolicyAdminImpl.class.getDeclaredConstructor(PolicyEngine.class);
        ctor.setAccessible(true);
        RangerPolicyAdminImpl admin = ctor.newInstance(policyEngine);

        // inject serviceDBStore field for modify-access flows
        Field f = RangerPolicyAdminImpl.class.getDeclaredField("serviceDBStore");
        f.setAccessible(true);
        f.set(admin, serviceDBStore);

        ServicePolicies sp = new ServicePolicies();
        PolicyEngine newEngine = mock(PolicyEngine.class);
        when(policyEngine.cloneWithDelta(sp)).thenReturn(newEngine);
        RangerPolicyAdmin ret = RangerPolicyAdminImpl.getPolicyAdmin(admin, sp);
        assertNotNull(ret);
        assertNotSame(admin, ret);
    }

    @Test
    public void testIsDelegatedAdminAccessAllowed_resource_noRepoReturnsFalse() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        // Make repository null to simulate no matching repo
        when(policyEngine.getRepositoryForZone(any())).thenReturn(null);
        RangerAccessResource res = mock(RangerAccessResource.class);
        Set<String> groups = new HashSet<>();
        Set<String> accessTypes = new HashSet<>(Arrays.asList("read", "write"));
        boolean allowed = admin.isDelegatedAdminAccessAllowed(res, null, "user", groups, accessTypes);
        assertFalse(allowed);
    }

    @Test
    public void testIsDelegatedAdminAccessAllowed_resource_allowedByEvaluator() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerAccessResource res = mock(RangerAccessResource.class);
        Set<String> groups = Collections.emptySet();
        Set<String> accessTypes = new HashSet<>(Arrays.asList("a", "b"));

        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        when(policyRepository.getLikelyMatchPolicyEvaluators(any(), anyInt())).thenReturn(Collections.singletonList(eval));
        when(eval.getAllowedAccesses(any(), anyString(), anySet(), anySet(), anySet())).thenReturn(new HashSet<>(Arrays.asList("a", "b")));

        boolean allowed = admin.isDelegatedAdminAccessAllowed(res, null, "u", groups, accessTypes);
        assertTrue(allowed);
    }

    @Test
    public void testIsDelegatedAdminAccessAllowedForRead_callsPrivateHelper() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerPolicy p = new RangerPolicy();
        p.setId(1L);
        p.setResources(new HashMap<>());
        Set<String> groups = Collections.emptySet();
        // returning empty access-types -> helper will compute based on service-def,
        // ends up defaulting to ADMIN if no accesses, then check allowedAccesses
        when(policyRepository.getPolicyEvaluators()).thenReturn(Collections.emptyList());
        boolean allowed = admin.isDelegatedAdminAccessAllowedForRead(p, "u", groups, null, null);
        assertFalse(allowed);
    }

    @Test
    public void testIsDelegatedAdminAccessAllowedForModify_withOldPolicySameResources() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerPolicy oldP = new RangerPolicy();
        oldP.setId(10L);
        oldP.setResources(Collections.singletonMap("db", new RangerPolicyResource("sales")));
        RangerPolicyItem item = new RangerPolicyItem();
        item.addUser("u");
        item.addAccess(new RangerPolicyItemAccess("read"));
        oldP.setPolicyItems(Collections.singletonList(item));

        RangerPolicy newP = new RangerPolicy();
        newP.setId(10L);
        newP.setResources(Collections.singletonMap("db", new RangerPolicyResource("sales")));
        RangerPolicyItem item2 = new RangerPolicyItem();
        item2.addUser("u");
        item2.addAccess(new RangerPolicyItemAccess("read"));
        newP.setPolicyItems(Collections.singletonList(item2));

        when(serviceDBStore.getPolicy(10L)).thenReturn(oldP);
        // allowed accesses for modifiedAccessTypes -> return containsAll
        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        when(policyRepository.getPolicyEvaluators()).thenReturn(Collections.singletonList(eval));
        when(eval.getAllowedAccesses(anyMap(), anyString(), anySet(), anySet(), anySet(), any()))
                .thenReturn(new HashSet<>(Collections.singletonList(RangerPolicyEngine.ADMIN_ACCESS)));

        boolean allowed = admin.isDelegatedAdminAccessAllowedForModify(newP, "u", Collections.emptySet(), null, null);
        assertTrue(allowed);
    }

    @Test
    public void testIsDelegatedAdminAccessAllowedForModify_oldPolicyMissingFallsBackToNew() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerPolicy newP = new RangerPolicy();
        newP.setId(99L);
        newP.setResources(Collections.singletonMap("db", new RangerPolicyResource("sales")));
        RangerPolicyItem item = new RangerPolicyItem();
        item.addUser("u");
        item.addAccess(new RangerPolicyItemAccess("read"));
        newP.setPolicyItems(Collections.singletonList(item));

        // Ensure service-def has 'read' access-type so getAllAccessTypes returns it
        RangerServiceDef sdWithRead = new RangerServiceDef();
        sdWithRead.setName("svc-def");
        sdWithRead.setResources(new ArrayList<>());
        List<RangerAccessTypeDef> accessTypesDef = new ArrayList<>();
        RangerAccessTypeDef at = new RangerAccessTypeDef();
        at.setName("read");
        accessTypesDef.add(at);
        sdWithRead.setAccessTypes(accessTypesDef);
        when(policyEngine.getServiceDef()).thenReturn(sdWithRead);

        when(serviceDBStore.getPolicy(99L)).thenReturn(null);
        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        when(policyRepository.getPolicyEvaluators()).thenReturn(Collections.singletonList(eval));
        // allowed-accesses must include all required accessTypes (read)
        when(eval.getAllowedAccesses(anyMap(), anyString(), anySet(), anySet(), anySet(), any()))
                .thenReturn(new HashSet<>(Arrays.asList("read", RangerPolicyEngine.ADMIN_ACCESS)));

        boolean allowed = admin.isDelegatedAdminAccessAllowedForModify(newP, "u", Collections.emptySet(), null, null);
        assertTrue(allowed);
    }

    @Test
    public void testGetExactMatchPolicies_byResource() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerAccessResource res = mock(RangerAccessResource.class);
        RangerPolicy p = new RangerPolicy();
        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        when(policyRepository.getPolicyEvaluators()).thenReturn(Collections.singletonList(eval));
        when(eval.isCompleteMatch(eq(res), any())).thenReturn(true);
        when(eval.getPolicy()).thenReturn(p);

        List<RangerPolicy> out = admin.getExactMatchPolicies(res, null, Collections.emptyMap());
        assertNotNull(out);
        assertEquals(1, out.size());
        assertSame(p, out.get(0));
    }

    @Test
    public void testGetExactMatchPolicies_byPolicy() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerPolicy p = new RangerPolicy();
        p.setResources(new HashMap<>());
        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        when(policyRepository.getPolicyEvaluators()).thenReturn(Collections.singletonList(eval));
        when(eval.isCompleteMatch(anyMap(), anyList(), any())).thenReturn(true);
        when(eval.getPolicy()).thenReturn(p);

        List<RangerPolicy> out = admin.getExactMatchPolicies(p, Collections.emptyMap());
        assertNotNull(out);
        assertEquals(1, out.size());
        assertSame(p, out.get(0));
    }

    @Test
    public void testGetMatchingPolicies_anyAccessEvaluatesResourcePolicies() throws Exception {
        // return a no-op lock for read/write locks to avoid touching real lock
        RangerLock noOpLock = mock(RangerLock.class);
        when(noOpLock.isLockingEnabled()).thenReturn(false);
        when(policyEngine.getReadLock()).thenReturn(noOpLock);

        // construct admin using the private ctor that accepts PolicyEngine
        Constructor<RangerPolicyAdminImpl> ctor = RangerPolicyAdminImpl.class.getDeclaredConstructor(PolicyEngine.class);
        ctor.setAccessible(true);
        RangerPolicyAdminImpl admin = ctor.newInstance(policyEngine);

        // inject serviceDBStore field for modify-access flows
        Field f = RangerPolicyAdminImpl.class.getDeclaredField("serviceDBStore");
        f.setAccessible(true);
        f.set(admin, serviceDBStore);

        when(policyEngine.getPluginContext()).thenReturn(pluginContext);
        when(pluginContext.getAuthContext()).thenReturn(authContext);
        when(policyEngine.getRepositoryForZone(any())).thenAnswer(inv -> policyRepository);
        when(policyEngine.hasResourcePolicies(any())).thenReturn(true);
        when(policyEngine.hasTagPolicies(any())).thenReturn(false);

        RangerAccessResource res = mock(RangerAccessResource.class);
        // preProcess requires pluginContext + config
        RangerPluginConfig pluginConfig = mock(RangerPluginConfig.class);
        when(pluginContext.getConfig()).thenReturn(pluginConfig);
        when(policyEngine.getPluginContext()).thenReturn(pluginContext);
        when(pluginConfig.getBoolean(anyString(), anyBoolean())).thenReturn(false);
        when(pluginConfig.getPropertyPrefix()).thenReturn("ranger.plugin.test");

        // Likely evaluators contain one whose resource matcher matches ANY
        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        RangerPolicyResourceEvaluator resEval = mock(RangerPolicyResourceEvaluator.class);
        RangerPolicyResourceMatcher matcher = mock(RangerPolicyResourceMatcher.class);
        when(eval.getResourceEvaluators()).thenReturn(Collections.singletonList(resEval));
        when(resEval.getPolicyResourceMatcher()).thenReturn(matcher);
        when(matcher.isMatch(any(RangerAccessResource.class), eq(RangerPolicyResourceMatcher.MatchScope.ANY), isNull())) .thenReturn(true);
        RangerPolicy policy = new RangerPolicy();
        when(eval.getPolicy()).thenReturn(policy);
        when(policyRepository.getLikelyMatchPolicyEvaluators(any(RangerAccessRequest.class))).thenReturn(Collections.singletonList(eval));
        when(policyEngine.getMatchedZonesForResourceAndChildren(any(RangerAccessResource.class))).thenReturn(Collections.emptySet());
        when(policyEngine.getRepositoryForZone(null)).thenReturn(policyRepository);

        List<RangerPolicy> out = admin.getMatchingPolicies(res);
        assertEquals(1, out.size());
        assertSame(policy, out.get(0));
    }

    @Test
    public void testGetPolicyVersionAndRoleVersionAndServiceInfo() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        when(policyEngine.getPolicyVersion()).thenReturn(5L);
        when(policyEngine.getRoleVersion()).thenReturn(7L);
        assertEquals(5L, admin.getPolicyVersion());
        assertEquals(7L, admin.getRoleVersion());
        assertEquals("svc", admin.getServiceName());
        assertNotNull(admin.getServiceDef());
    }

    @Test
    public void testGetRolesFromUserAndGroups_delegatesToAuthContext() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        Set<String> groups = new HashSet<>(Arrays.asList("g1", "g2"));
        when(authContext.getRolesForUserAndGroups("u", groups)).thenReturn(new HashSet<>(Collections.singleton("role1")));
        Set<String> roles = admin.getRolesFromUserAndGroups("u", groups);
        assertTrue(roles.contains("role1"));
    }

    @Test
    public void testGetZoneNamesForResource_callsEngine() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        Map<String, Object> resource = new HashMap<>();
        Set<String> zones = new HashSet<>(Arrays.asList("z1", "z2"));
        when(policyEngine.getMatchedZonesForResourceAndChildren(resource)).thenReturn(zones);
        Collection<String> out = admin.getZoneNamesForResource(resource);
        assertEquals(zones, out);
    }

    @Test
    public void testGetUniquelyMatchedZoneName_callsEngine() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        GrantRevokeRequest gr = new GrantRevokeRequest();
        Map<String, String> res = new HashMap<>();
        gr.setResource(res);
        when(policyEngine.getUniquelyMatchedZoneName(res)).thenReturn("z1");
        assertEquals("z1", admin.getUniquelyMatchedZoneName(gr));
    }

    @Test
    public void testIsAccessAllowedByUnzonedPolicies_trueIfAnyEvaluatorAllows() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        Map<String, RangerPolicyResource> res = new HashMap<>();
        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        when(policyRepository.getPolicyEvaluators()).thenReturn(Collections.singletonList(eval));
        when(eval.isAccessAllowed(anyMap(), anyList(), anyString(), anySet(), anyString())).thenReturn(true);
        assertTrue(admin.isAccessAllowedByUnzonedPolicies(res, null, "u", Collections.emptySet(), "read"));
    }

    @Test
    public void testGetAllowedUnzonedPolicies_collectsAllowed() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerPolicy p1 = new RangerPolicy();
        RangerPolicy p2 = new RangerPolicy();
        RangerPolicyEvaluator e1 = mock(RangerPolicyEvaluator.class);
        RangerPolicyEvaluator e2 = mock(RangerPolicyEvaluator.class);
        when(policyRepository.getPolicyEvaluators()).thenReturn(Arrays.asList(e1, e2));
        when(e1.getPolicy()).thenReturn(p1);
        when(e2.getPolicy()).thenReturn(p2);
        // delegate to isAccessAllowedByUnzonedPolicies -> make e1 true, e2 false via
        // direct call path
        when(e1.isAccessAllowed(anyMap(), anyList(), anyString(), anySet(), anyString())).thenReturn(true);
        when(e2.isAccessAllowed(anyMap(), anyList(), anyString(), anySet(), anyString())).thenReturn(false);
        List<RangerPolicy> out = admin.getAllowedUnzonedPolicies("u", Collections.emptySet(), "read");
        assertEquals(1, out.size());
        assertSame(p1, out.get(0));
    }

    @Test
    public void testSetServiceStore_setsOnlyIfServiceDBStore() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        ServiceStore store = mock(ServiceStore.class);
        admin.setServiceStore(store); // should NOT set
        // verify serviceDBStore remains what we injected in helper
        assertSame(serviceDBStore, getServiceDBStore(admin));
        // now set with ServiceDBStore instance
        admin.setServiceStore(serviceDBStore);
        assertSame(serviceDBStore, getServiceDBStore(admin));
    }

    @Test
    public void testReleaseResources_callsPreCleanup() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        admin.releaseResources(true);
        verify(policyEngine, times(1)).preCleanup(true);
    }

    @Test
    public void testGetAllAccessTypes_returnsImpliedAndSelf() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();

        RangerServiceDef sd = new RangerServiceDef();
        sd.setName("svc-def");
        sd.setResources(new ArrayList<>());
        List<RangerAccessTypeDef> accessTypes = new ArrayList<>();
        RangerAccessTypeDef read = new RangerAccessTypeDef();
        read.setName("read");
        read.setImpliedGrants(Arrays.asList("select"));
        RangerAccessTypeDef write = new RangerAccessTypeDef();
        write.setName("write");
        accessTypes.add(read);
        accessTypes.add(write);
        sd.setAccessTypes(accessTypes);
        when(policyEngine.getServiceDef()).thenReturn(sd);

        RangerPolicy p = new RangerPolicy();
        RangerPolicyItem it = new RangerPolicyItem();
        it.addAccess(new RangerPolicyItemAccess("read"));
        p.setPolicyItems(Collections.singletonList(it));

        Method m = RangerPolicyAdminImpl.class.getDeclaredMethod("getAllAccessTypes", RangerPolicy.class, RangerServiceDef.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        Set<String> ret = (Set<String>) m.invoke(admin, p, sd);
        assertTrue(ret.contains("read"));
        assertTrue(ret.contains("select"));
        assertFalse(ret.contains("write"));
    }

    @Test
    public void testGetAllAccessTypes_emptyAddsAdmin() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerServiceDef sd = new RangerServiceDef();
        sd.setName("svc-def");
        sd.setResources(new ArrayList<>());
        sd.setAccessTypes(new ArrayList<>());
        // add one access-type to make expanded map non-empty
        RangerAccessTypeDef at = new RangerAccessTypeDef();
        at.setName("read");
        sd.getAccessTypes().add(at);
        when(policyEngine.getServiceDef()).thenReturn(sd);
        RangerPolicy p = new RangerPolicy();
        p.setPolicyItems(new ArrayList<>());
        Method m = RangerPolicyAdminImpl.class.getDeclaredMethod("getAllAccessTypes", RangerPolicy.class, RangerServiceDef.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        Set<String> ret = (Set<String>) m.invoke(admin, p, sd);
        assertTrue(ret.contains(RangerPolicyEngine.ADMIN_ACCESS));
    }

    @Test
    public void testCollectAccessTypes_andGetAccessTypesDiff() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerServiceDef sd = new RangerServiceDef();
        sd.setName("svc-def");
        sd.setResources(new ArrayList<>());
        List<RangerAccessTypeDef> ats = new ArrayList<>();
        RangerAccessTypeDef rd = new RangerAccessTypeDef();
        rd.setName("read");
        RangerAccessTypeDef wr = new RangerAccessTypeDef();
        wr.setName("write");
        ats.add(rd);
        ats.add(wr);
        sd.setAccessTypes(ats);

        RangerPolicy oldP = new RangerPolicy();
        RangerPolicyItem oldIt = new RangerPolicyItem();
        oldIt.addUser("u");
        oldIt.addAccess(new RangerPolicyItemAccess("read"));
        oldP.setPolicyItems(Collections.singletonList(oldIt));

        RangerPolicy newP = new RangerPolicy();
        RangerPolicyItem newIt = new RangerPolicyItem();
        newIt.addUser("u");
        newIt.addAccess(new RangerPolicyItemAccess("write"));
        newP.setPolicyItems(Collections.singletonList(newIt));

        Map<String, Set<String>> oldUser = new HashMap<>();
        Map<String, Set<String>> oldGroup = new HashMap<>();
        Map<String, Set<String>> oldRole = new HashMap<>();
        Map<String, Set<String>> newUser = new HashMap<>();
        Map<String, Set<String>> newGroup = new HashMap<>();
        Map<String, Set<String>> newRole = new HashMap<>();

        Method collect = RangerPolicyAdminImpl.class.getDeclaredMethod("collectAccessTypes",
                RangerPolicy.class, RangerServiceDef.class, Map.class, Map.class, Map.class);
        collect.setAccessible(true);
        collect.invoke(admin, oldP, sd, oldUser, oldGroup, oldRole);
        collect.invoke(admin, newP, sd, newUser, newGroup, newRole);

        Method diff = RangerPolicyAdminImpl.class.getDeclaredMethod("getAccessTypesDiff", Map.class, Map.class);
        diff.setAccessible(true);
        @SuppressWarnings("unchecked")
        Set<String> changes = (Set<String>) diff.invoke(admin, newUser, oldUser);
        assertTrue(changes.contains("read") || changes.contains("write"));
    }

    @Test
    public void testGetMatchingPoliciesForZone_addsOnResourceMatch() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        RangerAccessResource res = mock(RangerAccessResource.class);
        RangerAccessRequestImpl req = new RangerAccessRequestImpl(res, "read", null, null, null);

        when(policyEngine.getRepositoryForZone(null)).thenReturn(policyRepository);
        when(policyEngine.hasTagPolicies(any())).thenReturn(false);
        when(policyEngine.hasResourcePolicies(any())).thenReturn(true);

        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        when(policyRepository.getLikelyMatchPolicyEvaluators(any(RangerAccessRequest.class))).thenReturn(Collections.singletonList(eval));
        RangerPolicyResourceEvaluator resEval = mock(RangerPolicyResourceEvaluator.class);
        when(eval.getResourceEvaluators()).thenReturn(Collections.singletonList(resEval));
        RangerPolicyResourceMatcher matcher = mock(RangerPolicyResourceMatcher.class);
        when(resEval.getPolicyResourceMatcher()).thenReturn(matcher);
        when(matcher.isMatch(any(RangerAccessResource.class), eq(RangerPolicyResourceMatcher.MatchScope.ANY), isNull())).thenReturn(true);
        RangerPolicy pol = new RangerPolicy();
        when(eval.getPolicy()).thenReturn(pol);

        List<RangerPolicy> out = new ArrayList<>();
        Method m = RangerPolicyAdminImpl.class.getDeclaredMethod("getMatchingPoliciesForZone", RangerAccessRequest.class, String.class, List.class);
        m.setAccessible(true);
        m.invoke(admin, req, null, out);
        assertEquals(1, out.size());
        assertSame(pol, out.get(0));
    }

    @Test
    public void testGetMatchingPolicies_privateWithAccessType() throws Exception {
        Constructor<RangerPolicyAdminImpl> ctor = RangerPolicyAdminImpl.class
                .getDeclaredConstructor(PolicyEngine.class);
        ctor.setAccessible(true);
        RangerPolicyAdminImpl admin = ctor.newInstance(policyEngine);
        Field f = RangerPolicyAdminImpl.class.getDeclaredField("serviceDBStore");
        f.setAccessible(true);
        f.set(admin, serviceDBStore);

        RangerPluginContext ctx = mock(RangerPluginContext.class);
        RangerPluginConfig cfg = mock(RangerPluginConfig.class);
        when(policyEngine.getPluginContext()).thenReturn(ctx);
        when(ctx.getConfig()).thenReturn(cfg);
        when(ctx.getAuthContext()).thenReturn(authContext);
        when(cfg.getBoolean(anyString(), anyBoolean())).thenReturn(false);
        when(cfg.getPropertyPrefix()).thenReturn("ranger.plugin.test");

        RangerAccessResource res = mock(RangerAccessResource.class);
        when(policyEngine.getMatchedZonesForResourceAndChildren(any(RangerAccessResource.class))).thenReturn(Collections.emptySet());
        RangerPolicyRepository matchedRepo = mock(RangerPolicyRepository.class);
        when(policyEngine.getRepositoryForZone(null)).thenReturn(matchedRepo);
        RangerPolicyEvaluator eval = mock(RangerPolicyEvaluator.class);
        when(matchedRepo.getLikelyMatchPolicyEvaluators(any(RangerAccessRequest.class))).thenReturn(Collections.singletonList(eval));
        RangerPolicyResourceEvaluator resEval = mock(RangerPolicyResourceEvaluator.class);
        when(eval.getResourceEvaluators()).thenReturn(Collections.singletonList(resEval));
        RangerPolicyResourceMatcher matcher = mock(RangerPolicyResourceMatcher.class);
        when(resEval.getPolicyResourceMatcher()).thenReturn(matcher);
        when(matcher.isMatch(any(RangerAccessResource.class), isNull())).thenReturn(true);
        RangerPolicy pol = new RangerPolicy();
        when(eval.getPolicy()).thenReturn(pol);
        when(policyEngine.hasResourcePolicies(matchedRepo)).thenReturn(true);

        Method m = RangerPolicyAdminImpl.class.getDeclaredMethod("getMatchingPolicies", RangerAccessResource.class, String.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        List<RangerPolicy> out = (List<RangerPolicy>) m.invoke(admin, res, "read");
        assertEquals(1, out.size());
    }

    @Test
    public void testCollectAccessTypes_overloadWithExpandedAccesses() throws Exception {
        RangerPolicyAdminImpl admin = createAdminWithDefaultStubs();
        Map<String, Collection<String>> expanded = new HashMap<>();
        expanded.put("read", new HashSet<>(Arrays.asList("read", "select")));

        RangerPolicyItem it = new RangerPolicyItem();
        it.addUser("user1");
        it.addAccess(new RangerPolicyItemAccess("read"));
        List<RangerPolicyItem> items = Collections.singletonList(it);

        Map<String, Set<String>> userAcc = new HashMap<>();
        Map<String, Set<String>> grpAcc = new HashMap<>();
        Map<String, Set<String>> roleAcc = new HashMap<>();

        Method m = RangerPolicyAdminImpl.class.getDeclaredMethod("collectAccessTypes", Map.class, List.class, Map.class, Map.class, Map.class);
        m.setAccessible(true);
        m.invoke(admin, expanded, items, userAcc, grpAcc, roleAcc);

        assertTrue(userAcc.containsKey("user1"));
        assertTrue(userAcc.get("user1").contains("read"));
        assertTrue(userAcc.get("user1").contains("select"));
    }

    private RangerPolicyAdminImpl createAdminWithDefaultStubs() throws Exception {
        // Minimal service-def to avoid NPEs in methods relying on it
        RangerServiceDef sd = new RangerServiceDef();
        sd.setName("svc-def");
        sd.setResources(new ArrayList<>());
        sd.setAccessTypes(new ArrayList<>());

        // stub frequently used PolicyEngine methods
        when(policyEngine.getServiceName()).thenReturn("svc");
        when(policyEngine.getServiceDef()).thenReturn(sd);
        when(policyEngine.getPluginContext()).thenReturn(pluginContext);
        when(pluginContext.getAuthContext()).thenReturn(authContext);
        when(policyEngine.getPolicyRepository()).thenReturn(policyRepository);
        when(policyEngine.getRepositoryForZone(any())).thenAnswer(inv -> policyRepository);
        when(policyEngine.getRepositoryForMatchedZone(any(RangerPolicy.class))).thenReturn(policyRepository);
        when(policyEngine.hasResourcePolicies(any())).thenReturn(true);
        when(policyEngine.hasTagPolicies(any())).thenReturn(false);

        // return a no-op lock for read/write locks to avoid touching real lock
        RangerLock noOpLock = mock(RangerLock.class);
        when(noOpLock.isLockingEnabled()).thenReturn(false);
        when(policyEngine.getReadLock()).thenReturn(noOpLock);
        when(policyEngine.getWriteLock()).thenReturn(noOpLock);

        // construct admin using the private ctor that accepts PolicyEngine
        Constructor<RangerPolicyAdminImpl> ctor = RangerPolicyAdminImpl.class.getDeclaredConstructor(PolicyEngine.class);
        ctor.setAccessible(true);
        RangerPolicyAdminImpl newAdmin = ctor.newInstance(policyEngine);

        // inject serviceDBStore field for modify-access flows
        Field f = RangerPolicyAdminImpl.class.getDeclaredField("serviceDBStore");
        f.setAccessible(true);
        f.set(newAdmin, serviceDBStore);
        return newAdmin;
    }

    private ServiceDBStore getServiceDBStore(RangerPolicyAdminImpl impl) {
        try {
            Field f = RangerPolicyAdminImpl.class.getDeclaredField("serviceDBStore");
            f.setAccessible(true);
            return (ServiceDBStore) f.get(impl);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
