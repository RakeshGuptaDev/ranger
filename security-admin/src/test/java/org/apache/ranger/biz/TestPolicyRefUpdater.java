/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.biz;

import org.apache.ranger.common.RESTErrorUtil;
import org.apache.ranger.common.db.RangerTransactionSynchronizationAdapter;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAccessTypeDefDao;
import org.apache.ranger.db.XXDataMaskTypeDefDao;
import org.apache.ranger.db.XXGroupDao;
import org.apache.ranger.db.XXPolicyConditionDefDao;
import org.apache.ranger.db.XXPolicyRefAccessTypeDao;
import org.apache.ranger.db.XXPolicyRefConditionDao;
import org.apache.ranger.db.XXPolicyRefDataMaskTypeDao;
import org.apache.ranger.db.XXPolicyRefGroupDao;
import org.apache.ranger.db.XXPolicyRefResourceDao;
import org.apache.ranger.db.XXPolicyRefRoleDao;
import org.apache.ranger.db.XXPolicyRefUserDao;
import org.apache.ranger.db.XXResourceDefDao;
import org.apache.ranger.db.XXRoleDao;
import org.apache.ranger.db.XXUserDao;
import org.apache.ranger.entity.XXAccessTypeDef;
import org.apache.ranger.entity.XXDataMaskTypeDef;
import org.apache.ranger.entity.XXPolicy;
import org.apache.ranger.entity.XXPolicyConditionDef;
import org.apache.ranger.entity.XXPolicyRefGroup;
import org.apache.ranger.entity.XXPolicyRefRole;
import org.apache.ranger.entity.XXPolicyRefUser;
import org.apache.ranger.entity.XXResourceDef;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.entity.XXUser;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerPolicy.RangerDataMaskPolicyItem;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItem;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItemAccess;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItemCondition;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItemDataMaskInfo;
import org.apache.ranger.plugin.model.RangerPolicy.RangerRowFilterPolicyItem;
import org.apache.ranger.plugin.model.RangerRole;
import org.apache.ranger.service.RangerAuditFields;
import org.apache.ranger.service.XGroupService;
import org.apache.ranger.view.VXGroup;
import org.apache.ranger.view.VXUser;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
* @generated by Cursor
* @description <Unit Test for TestPolicyRefUpdater class>
*/
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPolicyRefUpdater {
    @InjectMocks
    PolicyRefUpdater updater;

    @Mock
    RangerDaoManager daoMgr;
    @Mock
    RangerAuditFields<?> rangerAuditFields;
    @Mock
    XUserMgr xUserMgr;
    @Mock
    RoleDBStore roleStore;
    @Mock
    RangerBizUtil rangerBizUtil;
    @Mock
    XGroupService xGroupService;
    @Mock
    RangerTransactionSynchronizationAdapter rangerTransactionSynchronizationAdapter;
    @Mock
    RESTErrorUtil restErrorUtil;

    @Test
    public void testGetAllPolicyItemsAggregates() {
        RangerPolicy p = new RangerPolicy();
        p.setPolicyItems(Arrays.asList(new RangerPolicyItem()));
        p.setDenyPolicyItems(Arrays.asList(new RangerPolicyItem()));
        p.setAllowExceptions(Arrays.asList(new RangerPolicyItem()));
        p.setDenyExceptions(Arrays.asList(new RangerPolicyItem()));
        p.setDataMaskPolicyItems(Arrays.asList(new RangerDataMaskPolicyItem()));
        p.setRowFilterPolicyItems(Arrays.asList(new RangerRowFilterPolicyItem()));
        List<List<? extends RangerPolicyItem>> items = PolicyRefUpdater.getAllPolicyItems(p);
        assertEquals(6, items.size());
    }

    @Test
    public void testCreateNewPolMappingForRefTable_NullPolicyNoop() throws Exception {
        updater.createNewPolMappingForRefTable(null, null, null, false);
    }

    @Test
    public void testCreateNewPolMappingForRefTable_ValidEverything() throws Exception {
        // Prepare policy with resources and items
        RangerPolicy policy = new RangerPolicy();
        policy.setId(5L);
        policy.setName("p");
        policy.setService("svc");
        policy.setResources(Collections.singletonMap("db",
                new RangerPolicy.RangerPolicyResource(Collections.singletonList("db1"), false, false)));
        RangerPolicyItem item = new RangerPolicyItem();
        item.setUsers(Arrays.asList("u1"));
        item.setGroups(Arrays.asList("g1"));
        item.setRoles(Arrays.asList("r1"));
        RangerPolicyItemAccess acc = new RangerPolicyItemAccess();
        acc.setType("select");
        item.setAccesses(Collections.singletonList(acc));
        RangerPolicyItemCondition cond = new RangerPolicyItemCondition();
        cond.setType("time");
        item.setConditions(Collections.singletonList(cond));
        RangerDataMaskPolicyItem dmItem = new RangerDataMaskPolicyItem();
        RangerPolicyItemDataMaskInfo dm = new RangerPolicyItemDataMaskInfo();
        dm.setDataMaskType("MASK");
        dmItem.setDataMaskInfo(dm);
        policy.setPolicyItems(Arrays.asList(item));
        policy.setDataMaskPolicyItems(Arrays.asList(dmItem));
        policy.setConditions(Collections.singletonList(cond));

        XXPolicy xPolicy = new XXPolicy();
        xPolicy.setId(5L);
        xPolicy.setName("p");
        xPolicy.setService(9L);
        XXServiceDef xSvc = new XXServiceDef();
        xSvc.setId(9L);

        // Stubs for DAO lookups and batch create calls
        XXResourceDefDao resDefDao = mock(XXResourceDefDao.class);
        when(daoMgr.getXXResourceDef()).thenReturn(resDefDao);
        XXResourceDef xRes = new XXResourceDef();
        xRes.setId(1L);
        when(resDefDao.findByNameAndPolicyId("db", 5L)).thenReturn(xRes);
        Mockito.lenient().when(rangerAuditFields.populateAuditFields(Mockito.any(), Mockito.any()))
                .thenAnswer(inv -> inv.getArgument(0));
        XXPolicyRefResourceDao polResDao = mock(XXPolicyRefResourceDao.class);
        when(daoMgr.getXXPolicyRefResource()).thenReturn(polResDao);
        XXPolicyRefRoleDao polRoleDao = mock(XXPolicyRefRoleDao.class);
        when(daoMgr.getXXPolicyRefRole()).thenReturn(polRoleDao);
        XXPolicyRefGroupDao polGroupDao = mock(XXPolicyRefGroupDao.class);
        when(daoMgr.getXXPolicyRefGroup()).thenReturn(polGroupDao);
        XXPolicyRefUserDao polUserDao = mock(XXPolicyRefUserDao.class);
        when(daoMgr.getXXPolicyRefUser()).thenReturn(polUserDao);
        XXAccessTypeDefDao accDefDao = mock(XXAccessTypeDefDao.class);
        when(daoMgr.getXXAccessTypeDef()).thenReturn(accDefDao);
        XXAccessTypeDef xAcc = new XXAccessTypeDef();
        xAcc.setId(2L);
        when(accDefDao.findByNameAndServiceId("select", 9L)).thenReturn(xAcc);
        XXPolicyRefAccessTypeDao polAccDao = mock(XXPolicyRefAccessTypeDao.class);
        when(daoMgr.getXXPolicyRefAccessType()).thenReturn(polAccDao);
        XXPolicyConditionDefDao condDefDao = mock(XXPolicyConditionDefDao.class);
        when(daoMgr.getXXPolicyConditionDef()).thenReturn(condDefDao);
        XXPolicyConditionDef xCond = new XXPolicyConditionDef();
        xCond.setId(3L);
        when(condDefDao.findByServiceDefIdAndName(9L, "time")).thenReturn(xCond);
        XXPolicyRefConditionDao polCondDao = mock(XXPolicyRefConditionDao.class);
        when(daoMgr.getXXPolicyRefCondition()).thenReturn(polCondDao);
        XXDataMaskTypeDefDao dmDefDao = mock(XXDataMaskTypeDefDao.class);
        when(daoMgr.getXXDataMaskTypeDef()).thenReturn(dmDefDao);
        XXDataMaskTypeDef xDm = new XXDataMaskTypeDef();
        xDm.setId(4L);
        when(dmDefDao.findByNameAndServiceId("MASK", 9L)).thenReturn(xDm);
        XXPolicyRefDataMaskTypeDao polDmDao = mock(XXPolicyRefDataMaskTypeDao.class);
        when(daoMgr.getXXPolicyRefDataMaskType()).thenReturn(polDmDao);
        when(rangerBizUtil.checkAdminAccess()).thenReturn(true);

        // Principal creation path (user, group, role) when not existing and
        // createPrincipalsIfAbsent=true
        XXUserDao userDao = mock(XXUserDao.class);
        when(daoMgr.getXXUser()).thenReturn(userDao);
        when(userDao.findByUserName("u1")).thenReturn(null);
        when(daoMgr.getXXPolicyRefUser()).thenReturn(polUserDao);

        XXGroupDao groupDao = mock(XXGroupDao.class);
        when(daoMgr.getXXGroup()).thenReturn(groupDao);
        when(groupDao.findByGroupName("g1")).thenReturn(null);
        when(daoMgr.getXXPolicyRefGroup()).thenReturn(polGroupDao);

        XXRoleDao roleDao = mock(XXRoleDao.class);
        when(daoMgr.getXXRole()).thenReturn(roleDao);
        when(roleDao.findByRoleName("r1")).thenReturn(null);
        when(daoMgr.getXXPolicyRefRole()).thenReturn(polRoleDao);

        updater.createNewPolMappingForRefTable(policy, xPolicy, xSvc, true);
        // no exceptions indicates success across branches
    }

    @Test
    public void testCreateNewPolMappingForRefTable_InvalidResourceDef() throws Exception {
        RangerPolicy policy = new RangerPolicy();
        policy.setId(6L);
        policy.setName("p2");
        policy.setService("svc");
        policy.setResources(Collections.singletonMap("invalid",
                new RangerPolicy.RangerPolicyResource(Collections.singletonList("v"), false, false)));
        XXPolicy xPolicy = new XXPolicy();
        xPolicy.setId(6L);
        XXServiceDef xSvc = new XXServiceDef();
        xSvc.setId(9L);
        // ensure cleanupRefTables() doesn't NPE before resource lookup
        when(daoMgr.getXXPolicyRefResource()).thenReturn(mock(XXPolicyRefResourceDao.class));
        when(daoMgr.getXXPolicyRefRole()).thenReturn(mock(XXPolicyRefRoleDao.class));
        when(daoMgr.getXXPolicyRefGroup()).thenReturn(mock(XXPolicyRefGroupDao.class));
        when(daoMgr.getXXPolicyRefUser()).thenReturn(mock(XXPolicyRefUserDao.class));
        when(daoMgr.getXXPolicyRefAccessType()).thenReturn(mock(XXPolicyRefAccessTypeDao.class));
        when(daoMgr.getXXPolicyRefCondition()).thenReturn(mock(XXPolicyRefConditionDao.class));
        when(daoMgr.getXXPolicyRefDataMaskType()).thenReturn(mock(XXPolicyRefDataMaskTypeDao.class));
        XXResourceDefDao resDefDao = mock(XXResourceDefDao.class);
        when(daoMgr.getXXResourceDef()).thenReturn(resDefDao);
        when(resDefDao.findByNameAndPolicyId("invalid", 6L)).thenReturn(null);
        assertThrows(Exception.class, () -> updater.createNewPolMappingForRefTable(policy, xPolicy, xSvc, false));
    }

    @Test
    public void testCleanupRefTables() {
        when(daoMgr.getXXPolicyRefResource()).thenReturn(mock(XXPolicyRefResourceDao.class));
        when(daoMgr.getXXPolicyRefRole()).thenReturn(mock(XXPolicyRefRoleDao.class));
        when(daoMgr.getXXPolicyRefGroup()).thenReturn(mock(XXPolicyRefGroupDao.class));
        when(daoMgr.getXXPolicyRefUser()).thenReturn(mock(XXPolicyRefUserDao.class));
        when(daoMgr.getXXPolicyRefAccessType()).thenReturn(mock(XXPolicyRefAccessTypeDao.class));
        when(daoMgr.getXXPolicyRefCondition()).thenReturn(mock(XXPolicyRefConditionDao.class));
        when(daoMgr.getXXPolicyRefDataMaskType()).thenReturn(mock(XXPolicyRefDataMaskTypeDao.class));

        RangerPolicy p = new RangerPolicy();
        p.setId(77L);
        assertEquals(true, updater.cleanupRefTables(p));
        assertEquals(false, updater.cleanupRefTables(null));
    }

    @Test
    public void testCreatePrincipal_User_Group_Role_Paths() throws Exception {
        // Common setup: policy and xPolicy for audit fields
        XXPolicy xPolicy = new XXPolicy();
        xPolicy.setId(10L);
        xPolicy.setService(100L);

        // Mock audit population to be identity
        Mockito.lenient().when(rangerAuditFields.populateAuditFields(Mockito.any(), Mockito.any()))
                .thenAnswer(inv -> inv.getArgument(0));

        // USER path: user not found, xUserMgr creates, then XXUser lookup returns id
        XXUserDao userDao = mock(XXUserDao.class);
        when(daoMgr.getXXUser()).thenReturn(userDao);
        when(userDao.findByUserName("uNew")).thenReturn(null).thenReturn(new XXUser() {
            {
                setId(11L);
            }
        });
        VXUser createdVX = new VXUser();
        when(xUserMgr.createServiceConfigUser("uNew")).thenReturn(createdVX);
        XXPolicyRefUserDao polUserDao = mock(XXPolicyRefUserDao.class);
        when(daoMgr.getXXPolicyRefUser()).thenReturn(polUserDao);

        // Reflectively construct inner class PolicyPrincipalAssociator for USER
        Class<?> inner = null;
        for (Class<?> c : PolicyRefUpdater.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals("PolicyPrincipalAssociator")) {
                inner = c;
                break;
            }
        }
        assertNotNull(inner);
        Constructor<?> ctor = inner.getDeclaredConstructor(PolicyRefUpdater.class,
                PolicyRefUpdater.PRINCIPAL_TYPE.class, String.class, XXPolicy.class);
        ctor.setAccessible(true);
        Object associatorUser = ctor.newInstance(updater, PolicyRefUpdater.PRINCIPAL_TYPE.USER, "uNew", xPolicy);
        Method doAssociate = inner.getDeclaredMethod("doAssociate", boolean.class);
        doAssociate.setAccessible(true);
        Object resultUser = doAssociate.invoke(associatorUser, true);
        assertEquals(Boolean.TRUE, resultUser);
        verify(daoMgr.getXXPolicyRefUser(), Mockito.times(1))
                .create(Mockito.any(XXPolicyRefUser.class));

        // GROUP path: group not found, xGroupService creates and logs, verify ref
        // created
        XXGroupDao groupDao = mock(XXGroupDao.class);
        when(daoMgr.getXXGroup()).thenReturn(groupDao);
        when(groupDao.findByGroupName("gNew")).thenReturn(null);
        VXGroup vXGroup = new VXGroup();
        vXGroup.setId(22L);
        when(xGroupService.createXGroupWithOutLogin(Mockito.any(VXGroup.class))).thenReturn(vXGroup);
        XXPolicyRefGroupDao polGroupDao = mock(XXPolicyRefGroupDao.class);
        when(daoMgr.getXXPolicyRefGroup()).thenReturn(polGroupDao);

        Object associatorGroup = ctor.newInstance(updater, PolicyRefUpdater.PRINCIPAL_TYPE.GROUP, "gNew", xPolicy);
        Object resultGroup = doAssociate.invoke(associatorGroup, true);
        assertEquals(Boolean.TRUE, resultGroup);
        verify(daoMgr.getXXPolicyRefGroup(), Mockito.times(1))
                .create(Mockito.any(XXPolicyRefGroup.class));

        // ROLE path: role not found, roleStore.createRole returns id, verify ref
        // created
        XXRoleDao roleDao = mock(XXRoleDao.class);
        when(daoMgr.getXXRole()).thenReturn(roleDao);
        when(roleDao.findByRoleName("rNew")).thenReturn(null);
        RangerRole createdRole = new RangerRole("rNew", null, null, null, null);
        createdRole.setId(33L);
        when(roleStore.createRole(Mockito.any(RangerRole.class), Mockito.eq(false))).thenReturn(createdRole);
        XXPolicyRefRoleDao polRoleDao = mock(XXPolicyRefRoleDao.class);
        when(daoMgr.getXXPolicyRefRole()).thenReturn(polRoleDao);

        Object associatorRole = ctor.newInstance(updater, PolicyRefUpdater.PRINCIPAL_TYPE.ROLE, "rNew", xPolicy);
        Object resultRole = doAssociate.invoke(associatorRole, true);
        assertEquals(Boolean.TRUE, resultRole);
        verify(daoMgr.getXXPolicyRefRole(), Mockito.times(1)).create(Mockito.any(XXPolicyRefRole.class));
    }
}
