/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.plugin.geo;

import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description <Unit Test for BinarySearchTree class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestBinarySearchTree {
    @Test
    public void test01_insert_and_find() {
        BinarySearchTree<RangerGeolocationData, Long> tree = new BinarySearchTree<>();
        RangerGeolocationData a = RangerGeolocationData.create(new String[] {"1.1.1.1", "1.1.1.3", "A"}, 0, true);
        RangerGeolocationData b = RangerGeolocationData.create(new String[] {"1.1.1.4", "1.1.1.6", "B"}, 0, true);
        RangerGeolocationData c = RangerGeolocationData.create(new String[] {"1.1.1.7", "1.1.1.9", "C"}, 0, true);
        tree.insert(b);
        tree.insert(a);
        tree.insert(c);

        assertEquals("B", tree.find(RangerGeolocationData.ipAddressToLong("1.1.1.5")).getLocationData()[0]);
        assertEquals("A", tree.find(RangerGeolocationData.ipAddressToLong("1.1.1.2")).getLocationData()[0]);
        assertEquals("C", tree.find(RangerGeolocationData.ipAddressToLong("1.1.1.8")).getLocationData()[0]);
        assertNull(tree.find(RangerGeolocationData.ipAddressToLong("1.1.1.10")));
    }

    @Test
    public void test02_traversals_preOrder_and_inOrder() {
        BinarySearchTree<RangerGeolocationData, Long> tree = new BinarySearchTree<>();
        RangerGeolocationData a = RangerGeolocationData.create(new String[] {"1.1.1.1", "1.1.1.3", "A"}, 0, true);
        RangerGeolocationData b = RangerGeolocationData.create(new String[] {"1.1.1.4", "1.1.1.6", "B"}, 0, true);
        RangerGeolocationData c = RangerGeolocationData.create(new String[] {"1.1.1.0", "1.1.1.0", "C"}, 0, true);
        tree.insert(a);
        tree.insert(b);
        tree.insert(c);

        List<String> pre = new ArrayList<>();
        List<String> in = new ArrayList<>();

        tree.preOrderTraverseTree(value -> {
            pre.add(value.getLocationData()[0]);
            return value;
        });
        tree.inOrderTraverseTree(value -> {
            in.add(value.getLocationData()[0]);
            return value;
        });

        assertEquals(3, pre.size());
        assertEquals(3, in.size());
        assertTrue(in.contains("A") && in.contains("B") && in.contains("C"));
    }

    @Test
    public void test03_rebalance_changes_structure_but_preserves_find() {
        BinarySearchTree<RangerGeolocationData, Long> tree = new BinarySearchTree<>();
        for (int i = 0; i < 10; i++) {
            String start = "10.0.0." + (i * 2 + 1);
            String end = "10.0.0." + (i * 2 + 1);
            RangerGeolocationData data = RangerGeolocationData.create(new String[] {start, end, "V" + i}, 0, true);
            tree.insert(data);
        }

        RangerGeolocationData before = tree.find(RangerGeolocationData.ipAddressToLong("10.0.0.1"));
        assertNotNull(before);

        tree.rebalance();

        RangerGeolocationData after = tree.find(RangerGeolocationData.ipAddressToLong("10.0.0.1"));
        assertNotNull(after);
    }

    @Test
    public void test04_node_accessors_and_setRoot() {
        BinarySearchTree<RangerGeolocationData, Long> tree = new BinarySearchTree<>();
        BinarySearchTree.Node<RangerGeolocationData> node = new BinarySearchTree.Node<>(null);
        tree.setRoot(node);
        assertNotNull(tree.getRoot());
    }
}
