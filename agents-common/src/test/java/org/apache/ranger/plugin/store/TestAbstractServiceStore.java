/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.plugin.store;

import org.apache.ranger.authorization.hadoop.config.RangerAdminConfig;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerSecurityZone;
import org.apache.ranger.plugin.model.RangerService;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerAccessTypeDef;
import org.apache.ranger.plugin.util.SearchFilter;
import org.apache.ranger.plugin.util.ServicePolicies;
import org.apache.ranger.services.tag.RangerServiceTag;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * @generated by Cursor
 * @description <Unit Test for AbstractServiceStore class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestAbstractServiceStore {
    public static class MyServiceStore extends AbstractServiceStore {
        private final List<RangerServiceDef> sds;
        private final List<RangerService> svcs;
        private final List<RangerPolicy> pols;

        MyServiceStore(List<RangerServiceDef> sds, List<RangerService> svcs, List<RangerPolicy> pols) {
            this.sds = sds;
            this.svcs = svcs;
            this.pols = pols;
        }

        @Override
        protected void updateServicesForServiceDefUpdate(RangerServiceDef serviceDef) {
        }

        @Override
        public void init() {
        }

        @Override
        public RangerServiceDef createServiceDef(RangerServiceDef serviceDef) {
            return null;
        }

        @Override
        public RangerServiceDef updateServiceDef(RangerServiceDef serviceDef) {
            return null;
        }

        @Override
        public void deleteServiceDef(Long id, Boolean forceDelete) {
        }

        @Override
        public RangerServiceDef getServiceDef(Long id) {
            return null;
        }

        @Override
        public RangerServiceDef getServiceDefByName(String name) {
            return null;
        }

        @Override
        public RangerServiceDef getServiceDefByDisplayName(String name) {
            return null;
        }

        @Override
        public List<RangerServiceDef> getServiceDefs(SearchFilter filter) {
            return sds;
        }

        @Override
        public PList<RangerServiceDef> getPaginatedServiceDefs(SearchFilter filter) throws Exception {
            return super.getPaginatedServiceDefs(filter);
        }

        @Override
        public RangerService createService(RangerService service) {
            return null;
        }

        @Override
        public RangerService updateService(RangerService service, Map<String, Object> options) {
            return null;
        }

        @Override
        public void deleteService(Long id) {
        }

        @Override
        public boolean serviceExists(String name) {
            return false;
        }

        @Override
        public RangerService getService(Long id) {
            return null;
        }

        @Override
        public RangerService getServiceByName(String name) {
            return null;
        }

        @Override
        public RangerService getServiceByDisplayName(String displayName) {
            return null;
        }

        @Override
        public List<RangerService> getServices(SearchFilter filter) {
            return svcs;
        }

        @Override
        public PList<RangerService> getPaginatedServices(SearchFilter filter) throws Exception {
            return super.getPaginatedServices(filter);
        }

        @Override
        public RangerPolicy createPolicy(RangerPolicy policy) {
            return null;
        }

        @Override
        public RangerPolicy createDefaultPolicy(RangerPolicy policy) {
            return null;
        }

        @Override
        public RangerPolicy updatePolicy(RangerPolicy policy) {
            return null;
        }

        @Override
        public void deletePolicy(RangerPolicy policy, RangerService service) {
        }

        @Override
        public void deletePolicy(RangerPolicy policy) {
        }

        @Override
        public boolean policyExists(Long id) {
            return false;
        }

        @Override
        public RangerPolicy getPolicy(Long id) {
            return null;
        }

        @Override
        public List<RangerPolicy> getPolicies(SearchFilter filter) {
            return pols;
        }

        @Override
        public PList<RangerPolicy> getPaginatedPolicies(SearchFilter filter) throws Exception {
            return super.getPaginatedPolicies(filter);
        }

        @Override
        public Long getPolicyId(Long serviceId, String policyName, Long zoneId) {
            return null;
        }

        @Override
        public List<RangerPolicy> getServicePolicies(Long serviceId, SearchFilter filter) {
            return pols;
        }

        @Override
        public PList<RangerPolicy> getPaginatedServicePolicies(Long serviceId, SearchFilter filter) throws Exception {
            return super.getPaginatedServicePolicies(serviceId, filter);
        }

        @Override
        public List<RangerPolicy> getServicePolicies(String serviceName, SearchFilter filter) {
            return pols;
        }

        @Override
        public PList<RangerPolicy> getPaginatedServicePolicies(String serviceName, SearchFilter filter)
                throws Exception {
            return super.getPaginatedServicePolicies(serviceName, filter);
        }

        @Override
        public ServicePolicies getServicePoliciesIfUpdated(String serviceName, Long lastKnownVersion,
                boolean needsBackwardCompatibility) {
            return null;
        }

        @Override
        public Long getServicePolicyVersion(String serviceName) {
            return super.getServicePolicyVersion(serviceName);
        }

        @Override
        public ServicePolicies getServicePolicyDeltasOrPolicies(String serviceName, Long lastKnownVersion) {
            return null;
        }

        @Override
        public ServicePolicies getServicePolicyDeltas(String serviceName, Long lastKnownVersion,
                Long cachedPolicyVersion) {
            return null;
        }

        @Override
        public ServicePolicies getServicePolicies(String serviceName, Long lastKnownVersion) {
            return null;
        }

        @Override
        public RangerPolicy getPolicyFromEventTime(String eventTimeStr, Long policyId) {
            return null;
        }

        @Override
        public Boolean getPopulateExistingBaseFields() {
            return null;
        }

        @Override
        public void setPopulateExistingBaseFields(Boolean populateExistingBaseFields) {
        }

        @Override
        public RangerSecurityZone getSecurityZone(Long id) {
            return null;
        }

        @Override
        public RangerSecurityZone getSecurityZone(String name) {
            return null;
        }

        @Override
        public long getPoliciesCount(String serviceName) {
            return 0;
        }

        @Override
        public Map<String, String> getServiceConfigForPlugin(Long serviceId) {
            return null;
        }

        @Override
        public List<RangerPolicy> getPoliciesWithMetaAttributes(List<RangerPolicy> policies) {
            return policies;
        }

        @Override
        public List<RangerPolicy> getPoliciesByResourceSignature(String serviceName, String policySignature,
                Boolean isPolicyEnabled) {
            return pols;
        }
    }

    public static class UpdateStore extends MyServiceStore {
        public RangerServiceDef lastUpdated;
        private final Long tagId;
        private final RangerServiceDef tagRef;

        public UpdateStore(List<RangerServiceDef> sds, RangerServiceDef tagRef) {
            super(sds, new ArrayList<>(), new ArrayList<>());
            this.tagRef = tagRef;
            this.tagId = tagRef.getId();
        }

        @Override
        public RangerServiceDef getServiceDef(Long id) {
            return id != null && id.equals(tagId) ? tagRef : null;
        }

        @Override
        public RangerServiceDef updateServiceDef(RangerServiceDef serviceDef) {
            this.lastUpdated = serviceDef;
            return serviceDef;
        }
    }

    public static class CapturingStore extends MyServiceStore {
        public RangerServiceDef lastUpdated;

        public CapturingStore(List<RangerServiceDef> sds) {
            super(sds, new ArrayList<>(), new ArrayList<>());
        }

        @Override
        public RangerServiceDef updateServiceDef(RangerServiceDef serviceDef) {
            this.lastUpdated = serviceDef;
            return serviceDef;
        }
    }

    public static class ThrowingServiceStore extends MyServiceStore {
        public ThrowingServiceStore(List<RangerServiceDef> sds, List<RangerService> svcs, List<RangerPolicy> pols) {
            super(sds, svcs, pols);
        }

        @Override
        public RangerService getServiceByName(String name) {
            throw new RuntimeException("boom");
        }
    }

    public static class DeleteStore extends MyServiceStore {
        public RangerServiceDef lastUpdated;
        private final Long tagId;
        private final RangerServiceDef tagRef;

        public DeleteStore(List<RangerServiceDef> sds, RangerServiceDef tagRef) {
            super(sds, new ArrayList<>(), new ArrayList<>());
            this.tagRef = tagRef;
            this.tagId = tagRef.getId();
        }

        @Override
        public RangerServiceDef getServiceDef(Long id) {
            return id != null && id.equals(tagId) ? tagRef : null;
        }

        @Override
        public RangerServiceDef updateServiceDef(RangerServiceDef serviceDef) {
            this.lastUpdated = serviceDef;
            return serviceDef;
        }
    }

    public static class PostUpdateStore extends UpdateStore {
        public boolean servicesUpdated;

        public PostUpdateStore(List<RangerServiceDef> sds, RangerServiceDef tagRef) {
            super(sds, tagRef);
        }

        @Override
        protected void updateServicesForServiceDefUpdate(RangerServiceDef serviceDef) {
            servicesUpdated = true;
        }
    }

    @Test
    public void test01_getNextVersionAndPaginatedHelpers() throws Exception {
        Assertions.assertEquals(1L, AbstractServiceStore.getNextVersion(null));
        Assertions.assertEquals(6L, AbstractServiceStore.getNextVersion(5L));

        List<RangerServiceDef> sds = new ArrayList<>(Collections.singletonList(new RangerServiceDef()));
        List<RangerService> svcs = new ArrayList<>(Collections.singletonList(new RangerService()));
        List<RangerPolicy> pols = new ArrayList<>(Collections.singletonList(new RangerPolicy()));
        MyServiceStore store = new MyServiceStore(sds, svcs, pols);

        PList<RangerServiceDef> p1 = store.getPaginatedServiceDefs(new SearchFilter());
        Assertions.assertEquals(1, p1.getListSize());
        PList<RangerService> p2 = store.getPaginatedServices(new SearchFilter());
        Assertions.assertEquals(1, p2.getListSize());
        PList<RangerPolicy> p3 = store.getPaginatedPolicies(new SearchFilter());
        Assertions.assertEquals(1, p3.getListSize());

        PList<RangerPolicy> p4 = store.getPaginatedServicePolicies(1L, new SearchFilter());
        Assertions.assertEquals(1, p4.getListSize());
        PList<RangerPolicy> p5 = store.getPaginatedServicePolicies("svc", new SearchFilter());
        Assertions.assertEquals(1, p5.getListSize());
    }

    @Test
    public void test02_getServicePolicyVersionHandlesNullService() {
        List<RangerServiceDef> sds = new ArrayList<>();
        List<RangerService> svcs = new ArrayList<>();
        List<RangerPolicy> pols = new ArrayList<>();
        MyServiceStore store = new MyServiceStore(sds, svcs, pols);

        // getServiceByName returns null in stub; should return null and not throw
        Assertions.assertNull(store.getServicePolicyVersion("missing"));
    }

    @Test
    public void test03_getPaginatedServicePoliciesByNameAndId() throws Exception {
        List<RangerServiceDef> sds = new ArrayList<>();
        List<RangerService> svcs = new ArrayList<>();
        List<RangerPolicy> pols = new ArrayList<>();
        pols.add(new RangerPolicy());
        MyServiceStore store = new MyServiceStore(sds, svcs, pols);

        PList<RangerPolicy> pById = store.getPaginatedServicePolicies(5L, new SearchFilter());
        Assertions.assertEquals(1, pById.getList().size());
        PList<RangerPolicy> pByName = store.getPaginatedServicePolicies("svc1", new SearchFilter());
        Assertions.assertEquals(1, pByName.getList().size());
    }

    @Test
    public void test04_getServicePolicyVersion_whenGetServiceByNameThrows_returnsNull() {
        List<RangerServiceDef> sds = new ArrayList<>();
        List<RangerService> svcs = new ArrayList<>();
        List<RangerPolicy> pols = new ArrayList<>();
        ThrowingServiceStore store = new ThrowingServiceStore(sds, svcs, pols);

        Assertions.assertNull(store.getServicePolicyVersion("svc"));
    }

    @Test
    public void test05_getPaginatedEmptyLists() throws Exception {
        List<RangerServiceDef> sds = new ArrayList<>();
        List<RangerService> svcs = new ArrayList<>();
        List<RangerPolicy> pols = new ArrayList<>();
        MyServiceStore store = new MyServiceStore(sds, svcs, pols);

        PList<RangerServiceDef> p1 = store.getPaginatedServiceDefs(new SearchFilter());
        Assertions.assertEquals(0, p1.getListSize());
        PList<RangerService> p2 = store.getPaginatedServices(new SearchFilter());
        Assertions.assertEquals(0, p2.getListSize());
        PList<RangerPolicy> p3 = store.getPaginatedPolicies(new SearchFilter());
        Assertions.assertEquals(0, p3.getListSize());

        PList<RangerPolicy> p4 = store.getPaginatedServicePolicies(1L, new SearchFilter());
        Assertions.assertEquals(0, p4.getListSize());
        PList<RangerPolicy> p5 = store.getPaginatedServicePolicies("svc", new SearchFilter());
        Assertions.assertEquals(0, p5.getListSize());
    }

    @Test
    public void test06_updateTagServiceDefForAccessTypes_updatesAccessTypesMaskAndRowFilter() throws Exception {
        // Enable row-filter auto-propagation before store construction
        RangerAdminConfig.getInstance().set(AbstractServiceStore.AUTOPROPAGATE_ROWFILTERDEF_TO_TAG_PROP, "true");

        // Prepare service def "hdfs" with accessTypes, dataMask and rowFilter
        RangerServiceDef svcDef = new RangerServiceDef();
        svcDef.setId(2L);
        svcDef.setName("hdfs");
        List<RangerAccessTypeDef> svcAccess = new ArrayList<>();
        svcAccess.add(new RangerAccessTypeDef(1L, "read", "read", null, null));
        svcDef.setAccessTypes(svcAccess);

        RangerServiceDef.RangerDataMaskDef svcMaskDef = new RangerServiceDef.RangerDataMaskDef();
        List<RangerServiceDef.RangerDataMaskTypeDef> maskTypes = new ArrayList<>();
        maskTypes.add(new RangerServiceDef.RangerDataMaskTypeDef(1L, "MASK", "MASK", null, null, null, null, null));
        svcMaskDef.setMaskTypes(maskTypes);
        List<RangerAccessTypeDef> maskAccess = new ArrayList<>();
        maskAccess.add(new RangerAccessTypeDef(2L, "read", "read", null, null));
        svcMaskDef.setAccessTypes(maskAccess);
        svcDef.setDataMaskDef(svcMaskDef);

        RangerServiceDef.RangerRowFilterDef svcRowDef = new RangerServiceDef.RangerRowFilterDef();
        List<RangerAccessTypeDef> rowAccess = new ArrayList<>();
        rowAccess.add(new RangerAccessTypeDef(3L, "select", "select", null, null));
        svcRowDef.setAccessTypes(rowAccess);
        svcDef.setRowFilterDef(svcRowDef);

        // Prepare tag service-def with TAG resource
        RangerServiceDef tagDef = new RangerServiceDef();
        tagDef.setId(500L);
        tagDef.setName(RangerServiceTag.TAG_RESOURCE_NAME);
        List<RangerServiceDef.RangerResourceDef> tagResources = new ArrayList<>();
        RangerServiceDef.RangerResourceDef tagRes = new RangerServiceDef.RangerResourceDef();
        tagRes.setName(RangerServiceTag.TAG_RESOURCE_NAME);
        tagResources.add(tagRes);
        tagDef.setResources(tagResources);

        List<RangerServiceDef> sds = new ArrayList<>();
        sds.add(svcDef);
        UpdateStore store = new UpdateStore(sds, tagDef);

        // Wire EmbeddedServiceDefsUtil.tagServiceDef via reflection so
        // getTagServiceDefId() matches
        Field f = EmbeddedServiceDefsUtil.class.getDeclaredField("tagServiceDef");
        f.setAccessible(true);
        f.set(EmbeddedServiceDefsUtil.instance(), tagDef);

        store.updateTagServiceDefForAccessTypes();

        Assertions.assertNotNull(store.lastUpdated);
        // Access types propagated with prefix
        Assertions.assertTrue(tagDef.getAccessTypes().stream().anyMatch(a -> "hdfs:read".equals(a.getName())));
        // Data mask: mask type added with prefixed name and itemId offset 2*(1000+1)+1
        // = 2003
        RangerServiceDef.RangerDataMaskDef updatedMaskDef = tagDef.getDataMaskDef();
        Assertions.assertTrue(updatedMaskDef.getMaskTypes().stream().anyMatch(m -> "hdfs:MASK".equals(m.getName())));
        Assertions.assertEquals(1, updatedMaskDef.getResources().size());
        Assertions.assertEquals(RangerServiceTag.TAG_RESOURCE_NAME, updatedMaskDef.getResources().get(0).getName());
        // Row filter propagated and resources set due to auto-propagation
        RangerServiceDef.RangerRowFilterDef updatedRowDef = tagDef.getRowFilterDef();
        Assertions.assertTrue(updatedRowDef.getAccessTypes().stream().anyMatch(a -> "hdfs:select".equals(a.getName())));
        Assertions.assertEquals(1, updatedRowDef.getResources().size());
        Assertions.assertEquals(RangerServiceTag.TAG_RESOURCE_NAME, updatedRowDef.getResources().get(0).getName());
    }

    @Test
    public void test07_updateTagServiceDefForAccessTypes_tagServiceDefMissing_noUpdate() throws Exception {
        // Ensure EmbeddedServiceDefsUtil has no tag service-def
        Field f = EmbeddedServiceDefsUtil.class.getDeclaredField("tagServiceDef");
        f.setAccessible(true);
        f.set(EmbeddedServiceDefsUtil.instance(), null);

        RangerServiceDef svcDef = new RangerServiceDef();
        svcDef.setId(1L);
        svcDef.setName("hdfs");
        svcDef.setAccessTypes(new ArrayList<>());

        List<RangerServiceDef> sds = new ArrayList<>();
        sds.add(svcDef);
        CapturingStore store = new CapturingStore(sds);

        store.updateTagServiceDefForAccessTypes();

        Assertions.assertNull(store.lastUpdated);
    }

    @Test
    public void test08_postDelete_removesPrefixedAccessTypesAndClearsResourcesWhenEmpty() throws Exception {
        // Prepare tag service-def with resources and some prefixed entries
        RangerServiceDef tagDef = new RangerServiceDef();
        tagDef.setId(600L);
        tagDef.setName(RangerServiceTag.TAG_RESOURCE_NAME);
        List<RangerServiceDef.RangerResourceDef> tagResources = new ArrayList<>();
        RangerServiceDef.RangerResourceDef tagRes = new RangerServiceDef.RangerResourceDef();
        tagRes.setName(RangerServiceTag.TAG_RESOURCE_NAME);
        tagResources.add(tagRes);
        tagDef.setResources(tagResources);

        List<RangerAccessTypeDef> tagAccess = new ArrayList<>();
        tagAccess.add(new RangerAccessTypeDef(1L, "hdfs:read", "hdfs:read", null, null));
        tagAccess.add(new RangerAccessTypeDef(2L, "kafka:publish", "kafka:publish", null, null));
        tagAccess.add(new RangerAccessTypeDef(3L, "hdfs:write", "hdfs:write", null, null));
        tagDef.setAccessTypes(tagAccess);

        RangerServiceDef.RangerDataMaskDef tagMask = new RangerServiceDef.RangerDataMaskDef();
        List<RangerAccessTypeDef> maskAccess = new ArrayList<>();
        maskAccess.add(new RangerAccessTypeDef(10L, "hdfs:read", "hdfs:read", null, null));
        tagMask.setAccessTypes(maskAccess);
        List<RangerServiceDef.RangerDataMaskTypeDef> maskTypes = new ArrayList<>();
        maskTypes.add(new RangerServiceDef.RangerDataMaskTypeDef(11L, "hdfs:MASK", "hdfs:MASK", null, null, null, null,
                null));
        tagMask.setMaskTypes(maskTypes);
        List<RangerServiceDef.RangerResourceDef> maskRes = new ArrayList<>();
        maskRes.add(tagRes);
        tagMask.setResources(maskRes);
        tagDef.setDataMaskDef(tagMask);

        RangerServiceDef.RangerRowFilterDef tagRow = new RangerServiceDef.RangerRowFilterDef();
        List<RangerAccessTypeDef> rowAccess = new ArrayList<>();
        rowAccess.add(new RangerAccessTypeDef(20L, "hdfs:select", "hdfs:select", null, null));
        tagRow.setAccessTypes(rowAccess);
        List<RangerServiceDef.RangerResourceDef> rowRes = new ArrayList<>();
        rowRes.add(tagRes);
        tagRow.setResources(rowRes);
        tagDef.setRowFilterDef(tagRow);

        // Set tag service-def in EmbeddedServiceDefsUtil
        Field f = EmbeddedServiceDefsUtil.class.getDeclaredField("tagServiceDef");
        f.setAccessible(true);
        f.set(EmbeddedServiceDefsUtil.instance(), tagDef);

        RangerServiceDef svcDef = new RangerServiceDef();
        svcDef.setId(2L);
        svcDef.setName("hdfs");

        List<RangerServiceDef> sds = new ArrayList<>();
        sds.add(svcDef);
        DeleteStore store = new DeleteStore(sds, tagDef);

        store.postDelete(svcDef);

        Assertions.assertNotNull(store.lastUpdated);
        // Prefixed access types removed
        Assertions.assertTrue(tagDef.getAccessTypes().stream().noneMatch(a -> a.getName().startsWith("hdfs:")));
        Assertions.assertTrue(tagDef.getAccessTypes().stream().anyMatch(a -> a.getName().equals("kafka:publish")));
        // Data mask and row filter entries for hdfs removed; since accessTypes become
        // empty, resources should be cleared by updateResourceInTagServiceDef
        Assertions.assertTrue(tagDef.getDataMaskDef().getAccessTypes().isEmpty());
        Assertions.assertTrue(tagDef.getDataMaskDef().getMaskTypes().isEmpty());
        Assertions.assertTrue(tagDef.getDataMaskDef().getResources().isEmpty());
        Assertions.assertTrue(tagDef.getRowFilterDef().getAccessTypes().isEmpty());
        Assertions.assertTrue(tagDef.getRowFilterDef().getResources().isEmpty());
    }

    @Test
    public void test09_postCreate_updatesTagServiceDef_whenServiceDefCreated() throws Exception {
        RangerServiceDef svcDef = new RangerServiceDef();
        svcDef.setId(3L);
        svcDef.setName("hdfs");
        List<RangerAccessTypeDef> svcAccess = new ArrayList<>();
        svcAccess.add(new RangerAccessTypeDef(1L, "read", "read", null, null));
        svcDef.setAccessTypes(svcAccess);

        RangerServiceDef tagDef = new RangerServiceDef();
        tagDef.setId(700L);
        tagDef.setName(RangerServiceTag.TAG_RESOURCE_NAME);
        List<RangerServiceDef.RangerResourceDef> tagResources = new ArrayList<>();
        RangerServiceDef.RangerResourceDef tagRes = new RangerServiceDef.RangerResourceDef();
        tagRes.setName(RangerServiceTag.TAG_RESOURCE_NAME);
        tagResources.add(tagRes);
        tagDef.setResources(tagResources);

        List<RangerServiceDef> sds = new ArrayList<>();
        sds.add(svcDef);
        UpdateStore store = new UpdateStore(sds, tagDef);

        Field f = EmbeddedServiceDefsUtil.class.getDeclaredField("tagServiceDef");
        f.setAccessible(true);
        f.set(EmbeddedServiceDefsUtil.instance(), tagDef);

        store.postCreate(svcDef);

        Assertions.assertNotNull(store.lastUpdated);
        Assertions.assertTrue(tagDef.getAccessTypes().stream().anyMatch(a -> "hdfs:read".equals(a.getName())));
    }

    @Test
    public void test10_postCreate_nonServiceDef_noop() throws Exception {
        RangerServiceDef tagDef = new RangerServiceDef();
        tagDef.setId(701L);
        tagDef.setName(RangerServiceTag.TAG_RESOURCE_NAME);

        List<RangerServiceDef> sds = new ArrayList<>();
        UpdateStore store = new UpdateStore(sds, tagDef);

        Field f = EmbeddedServiceDefsUtil.class.getDeclaredField("tagServiceDef");
        f.setAccessible(true);
        f.set(EmbeddedServiceDefsUtil.instance(), tagDef);

        store.postCreate(new RangerPolicy());
        Assertions.assertNull(store.lastUpdated);
    }

    @Test
    public void test11_postUpdate_updatesTagServiceDef_andInvokesServicesUpdate() throws Exception {
        RangerServiceDef svcDef = new RangerServiceDef();
        svcDef.setId(4L);
        svcDef.setName("kafka");
        List<RangerAccessTypeDef> svcAccess = new ArrayList<>();
        svcAccess.add(new RangerAccessTypeDef(1L, "publish", "publish", null, null));
        svcDef.setAccessTypes(svcAccess);

        RangerServiceDef tagDef = new RangerServiceDef();
        tagDef.setId(702L);
        tagDef.setName(RangerServiceTag.TAG_RESOURCE_NAME);

        List<RangerServiceDef> sds = new ArrayList<>();
        sds.add(svcDef);
        PostUpdateStore store = new PostUpdateStore(sds, tagDef);

        Field f = EmbeddedServiceDefsUtil.class.getDeclaredField("tagServiceDef");
        f.setAccessible(true);
        f.set(EmbeddedServiceDefsUtil.instance(), tagDef);

        store.postUpdate(svcDef);

        Assertions.assertNotNull(store.lastUpdated);
        Assertions.assertTrue(store.servicesUpdated);
        Assertions.assertTrue(tagDef.getAccessTypes().stream().anyMatch(a -> "kafka:publish".equals(a.getName())));
    }

    @Test
    public void test12_postUpdate_nonServiceDef_noop() throws Exception {
        RangerServiceDef tagDef = new RangerServiceDef();
        tagDef.setId(703L);
        tagDef.setName(RangerServiceTag.TAG_RESOURCE_NAME);

        List<RangerServiceDef> sds = new ArrayList<>();
        PostUpdateStore store = new PostUpdateStore(sds, tagDef);

        Field f = EmbeddedServiceDefsUtil.class.getDeclaredField("tagServiceDef");
        f.setAccessible(true);
        f.set(EmbeddedServiceDefsUtil.instance(), tagDef);

        store.postUpdate(new RangerPolicy());
        Assertions.assertNull(store.lastUpdated);
        Assertions.assertFalse(store.servicesUpdated);
    }

    @Test
    public void test13_getServicePolicyVersion_success() {
        List<RangerServiceDef> sds = new ArrayList<>();
        List<RangerPolicy> pols = new ArrayList<>();
        List<RangerService> svcs = new ArrayList<>();

        MyServiceStore store = new MyServiceStore(sds, svcs, pols) {
            @Override
            public Long getServicePolicyVersion(String serviceName) {
                return super.getServicePolicyVersion(serviceName);
            }

            @Override
            public RangerService getServiceByName(String name) {
                RangerService svc = new RangerService();
                svc.setPolicyVersion(9L);
                return svc;
            }
        };

        Assertions.assertEquals(9L, store.getServicePolicyVersion("svc"));
    }

    @Test
    public void test14_updateTagAccessTypeDef_noChange_returnsFalse() throws Exception {
        MyServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        RangerAccessTypeDef svcAccess = new RangerAccessTypeDef(1L, "read", "lbl", "rb", null);
        List<String> svcImplied = new ArrayList<>();
        svcImplied.add("write");
        svcAccess.setImpliedGrants(svcImplied);

        RangerAccessTypeDef tagAccess = new RangerAccessTypeDef(1001L, "hdfs:read", "lbl", "rb", null);
        List<String> tagImplied = new ArrayList<>();
        tagImplied.add("hdfs:write");
        tagAccess.setImpliedGrants(tagImplied);

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagAccessTypeDef",
                RangerAccessTypeDef.class,
                RangerAccessTypeDef.class,
                String.class);
        m.setAccessible(true);

        Boolean updated = (Boolean) m.invoke(store, tagAccess, svcAccess, "hdfs:");
        Assertions.assertFalse(updated);
        Assertions.assertEquals("hdfs:read", tagAccess.getName());
        Assertions.assertEquals("lbl", tagAccess.getLabel());
        Assertions.assertEquals("rb", tagAccess.getRbKeyLabel());
        Assertions.assertTrue(tagAccess.getImpliedGrants().contains("hdfs:write"));
    }

    @Test
    public void test15_updateTagAccessTypeDef_nameDiff_updatesAndPrefixesImpliedGrants() throws Exception {
        MyServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        RangerAccessTypeDef svcAccess = new RangerAccessTypeDef(1L, "read", "lbl2", "rb2", null);
        List<String> svcImplied = new ArrayList<>();
        svcImplied.add("write");
        svcImplied.add("execute");
        svcAccess.setImpliedGrants(svcImplied);

        RangerAccessTypeDef tagAccess = new RangerAccessTypeDef(1001L, "other", "old", "oldrb", null);
        List<String> tagImplied = new ArrayList<>();
        tagImplied.add("hdfs:old");
        tagAccess.setImpliedGrants(tagImplied);

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagAccessTypeDef",
                RangerAccessTypeDef.class,
                RangerAccessTypeDef.class,
                String.class);
        m.setAccessible(true);

        Boolean updated = (Boolean) m.invoke(store, tagAccess, svcAccess, "hdfs:");
        Assertions.assertTrue(updated);
        Assertions.assertEquals("hdfs:read", tagAccess.getName());
        Assertions.assertEquals("lbl2", tagAccess.getLabel());
        Assertions.assertEquals("rb2", tagAccess.getRbKeyLabel());
        Assertions.assertTrue(tagAccess.getImpliedGrants().contains("hdfs:write"));
        Assertions.assertTrue(tagAccess.getImpliedGrants().contains("hdfs:execute"));
    }

    @Test
    public void test16_updateTagAccessTypeDef_impliedGrantMissing_updates() throws Exception {
        MyServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        RangerAccessTypeDef svcAccess = new RangerAccessTypeDef(1L, "read", "lbl", "rb", null);
        List<String> svcImplied = new ArrayList<>();
        svcImplied.add("write");
        svcImplied.add("execute");
        svcAccess.setImpliedGrants(svcImplied);

        // tag has correct name/labels but only one implied grant; missing one should trigger update via inner loop
        RangerAccessTypeDef tagAccess = new RangerAccessTypeDef(1001L, "hdfs:read", "lbl", "rb", null);
        List<String> tagImplied = new ArrayList<>();
        tagImplied.add("hdfs:write");
        tagAccess.setImpliedGrants(tagImplied);

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagAccessTypeDef",
                RangerAccessTypeDef.class,
                RangerAccessTypeDef.class,
                String.class);
        m.setAccessible(true);

        Boolean updated = (Boolean) m.invoke(store, tagAccess, svcAccess, "hdfs:");
        Assertions.assertTrue(updated);
        Assertions.assertTrue(tagAccess.getImpliedGrants().contains("hdfs:write"));
        Assertions.assertTrue(tagAccess.getImpliedGrants().contains("hdfs:execute"));
    }

    @Test
    public void test17_updateTagAccessTypeDef_labelOrRbKeyDiff_updates() throws Exception {
        MyServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        // Same name once prefix is removed, but label differs
        RangerAccessTypeDef svcAccess = new RangerAccessTypeDef(1L, "read", "newLbl", "newRb", null);
        List<String> svcImplied = new ArrayList<>();
        svcImplied.add("write");
        svcAccess.setImpliedGrants(svcImplied);

        RangerAccessTypeDef tagAccess = new RangerAccessTypeDef(1001L, "hdfs:read", "oldLbl", "oldRb", null);
        List<String> tagImplied = new ArrayList<>();
        tagImplied.add("hdfs:write");
        tagAccess.setImpliedGrants(tagImplied);

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagAccessTypeDef",
                RangerAccessTypeDef.class,
                RangerAccessTypeDef.class,
                String.class);
        m.setAccessible(true);

        Boolean updated = (Boolean) m.invoke(store, tagAccess, svcAccess, "hdfs:");
        Assertions.assertTrue(updated);
        Assertions.assertEquals("hdfs:read", tagAccess.getName());
        Assertions.assertEquals("newLbl", tagAccess.getLabel());
        Assertions.assertEquals("newRb", tagAccess.getRbKeyLabel());
        Assertions.assertTrue(tagAccess.getImpliedGrants().contains("hdfs:write"));
    }

    @Test
    void test18_findAccessTypeDef_found() throws Exception {
        AbstractServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        List<RangerAccessTypeDef> list = new ArrayList<>();
        list.add(new RangerAccessTypeDef(1L, "a", "a", null, null));
        list.add(new RangerAccessTypeDef(2L, "b", "b", null, null));

        Method m = AbstractServiceStore.class.getDeclaredMethod("findAccessTypeDef", long.class, List.class);
        m.setAccessible(true);

        Object ret = m.invoke(store, 2L, list);
        Assertions.assertNotNull(ret);
        Assertions.assertEquals(2L, ((RangerAccessTypeDef) ret).getItemId());
    }

    @Test
    void test19_findAccessTypeDef_notFound() throws Exception {
        AbstractServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        List<RangerAccessTypeDef> list = new ArrayList<>();
        list.add(new RangerAccessTypeDef(3L, "a", "a", null, null));
        list.add(new RangerAccessTypeDef(4L, "b", "b", null, null));

        Method m = AbstractServiceStore.class.getDeclaredMethod("findAccessTypeDef", long.class, List.class);
        m.setAccessible(true);

        Object ret = m.invoke(store, 2L, list);
        Assertions.assertNull(ret);
    }

    @Test
    void test20_updateTagAccessTypeDefs_addsMissingFromSvc() throws Exception {
        AbstractServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        List<RangerAccessTypeDef> svc = new ArrayList<>();
        RangerAccessTypeDef svcRead = new RangerAccessTypeDef(1L, "read", "lbl", "rb", null);
        List<String> svcImpl = new ArrayList<>();
        svcImpl.add("write");
        svcRead.setImpliedGrants(svcImpl);
        svc.add(svcRead);

        List<RangerAccessTypeDef> tag = new ArrayList<>();

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagAccessTypeDefs", List.class, List.class, long.class, String.class);
        m.setAccessible(true);

        Boolean updated = (Boolean) m.invoke(store, svc, tag, 100L, "hdfs:");
        Assertions.assertTrue(updated);
        Assertions.assertEquals(1, tag.size());
        Assertions.assertEquals(Long.valueOf(101L), tag.get(0).getItemId());
        Assertions.assertEquals("hdfs:read", tag.get(0).getName());
        Assertions.assertTrue(tag.get(0).getImpliedGrants().contains("hdfs:write"));
    }

    @Test
    void test21_updateTagAccessTypeDefs_updatesChangedEntries() throws Exception {
        AbstractServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        List<RangerAccessTypeDef> svc = new ArrayList<>();
        RangerAccessTypeDef svcRead = new RangerAccessTypeDef(2L, "read", "newLbl", "newRb", null);
        List<String> svcImpl = new ArrayList<>();
        svcImpl.add("execute");
        svcRead.setImpliedGrants(svcImpl);
        svc.add(svcRead);

        List<RangerAccessTypeDef> tag = new ArrayList<>();
        RangerAccessTypeDef tagRead = new RangerAccessTypeDef(1002L, "hdfs:old", "oldLbl", "oldRb", null);
        List<String> tagImpl = new ArrayList<>();
        tagImpl.add("hdfs:write");
        tagRead.setImpliedGrants(tagImpl);
        tag.add(tagRead);

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagAccessTypeDefs", List.class, List.class, long.class, String.class);
        m.setAccessible(true);

        Boolean updated = (Boolean) m.invoke(store, svc, tag, 100L, "hdfs:");
        Assertions.assertTrue(updated);
        Assertions.assertEquals(1, tag.size());
        Assertions.assertEquals("hdfs:read", tag.get(0).getName());
        Assertions.assertEquals("newLbl", tag.get(0).getLabel());
        Assertions.assertEquals("newRb", tag.get(0).getRbKeyLabel());
        Assertions.assertTrue(tag.get(0).getImpliedGrants().contains("hdfs:execute"));
    }

    @Test
    void test22_updateTagAccessTypeDefs_deletesRemovedFromSvc() throws Exception {
        AbstractServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        List<RangerAccessTypeDef> svc = new ArrayList<>();
        // svc intentionally empty to trigger deletion of prefixed tag entry

        List<RangerAccessTypeDef> tag = new ArrayList<>();
        RangerAccessTypeDef tagWrite = new RangerAccessTypeDef(1003L, "hdfs:write", "write", null, null);
        tag.add(tagWrite);

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagAccessTypeDefs", List.class, List.class, long.class, String.class);
        m.setAccessible(true);

        Boolean updated = (Boolean) m.invoke(store, svc, tag, 100L, "hdfs:");
        Assertions.assertTrue(updated);
        Assertions.assertTrue(tag.isEmpty());
    }

    @Test
    void test23_updateTagAccessTypeDefs_noChanges_returnsFalse() throws Exception {
        AbstractServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        List<RangerAccessTypeDef> svc = new ArrayList<>();
        RangerAccessTypeDef svcRead = new RangerAccessTypeDef(1L, "read", "lbl", "rb", null);
        List<String> svcImpl = new ArrayList<>();
        svcImpl.add("write");
        svcRead.setImpliedGrants(svcImpl);
        svc.add(svcRead);

        List<RangerAccessTypeDef> tag = new ArrayList<>();
        RangerAccessTypeDef tagRead = new RangerAccessTypeDef(101L, "hdfs:read", "lbl", "rb", null);
        List<String> tagImpl = new ArrayList<>();
        tagImpl.add("hdfs:write");
        tagRead.setImpliedGrants(tagImpl);
        tag.add(tagRead);

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagAccessTypeDefs", List.class, List.class, long.class, String.class);
        m.setAccessible(true);

        Boolean updated = (Boolean) m.invoke(store, svc, tag, 100L, "hdfs:");
        Assertions.assertFalse(updated);
        Assertions.assertEquals(1, tag.size());
        Assertions.assertEquals("hdfs:read", tag.get(0).getName());
    }

    private RangerServiceDef makeSvcWithMask(long svcId, String svcName, List<RangerServiceDef.RangerDataMaskTypeDef> maskTypes, List<RangerAccessTypeDef> maskAccess) {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setId(svcId);
        svc.setName(svcName);
        RangerServiceDef.RangerDataMaskDef maskDef = new RangerServiceDef.RangerDataMaskDef();
        maskDef.setMaskTypes(maskTypes);
        maskDef.setAccessTypes(maskAccess);
        svc.setDataMaskDef(maskDef);
        return svc;
    }

    private RangerServiceDef makeTagWithMask(List<RangerServiceDef.RangerDataMaskTypeDef> maskTypes, List<RangerAccessTypeDef> maskAccess) {
        RangerServiceDef tag = new RangerServiceDef();
        tag.setId(999L);
        tag.setName(RangerServiceTag.TAG_RESOURCE_NAME);
        RangerServiceDef.RangerDataMaskDef maskDef = new RangerServiceDef.RangerDataMaskDef();
        maskDef.setMaskTypes(maskTypes);
        maskDef.setAccessTypes(maskAccess);
        tag.setDataMaskDef(maskDef);
        return tag;
    }

    @Test
    void test24_updateTagServiceDefForUpdatingDataMaskDef_add_update_delete_and_nochange() throws Exception {
        AbstractServiceStore store = new MyServiceStore(new ArrayList<>(), new ArrayList<>(), new ArrayList<>());

        // Add scenario: tag has none, svc has one mask type and one access type
        List<RangerServiceDef.RangerDataMaskTypeDef> svcMaskTypesAdd = new ArrayList<>();
        svcMaskTypesAdd.add(new RangerServiceDef.RangerDataMaskTypeDef(1L, "MASK", "MASK", null, null, null, null, null));
        List<RangerAccessTypeDef> svcMaskAccessAdd = new ArrayList<>();
        svcMaskAccessAdd.add(new RangerAccessTypeDef(2L, "read", "read", null, null));
        RangerServiceDef svcAdd = makeSvcWithMask(5L, "hdfs", svcMaskTypesAdd, svcMaskAccessAdd);

        RangerServiceDef tagAdd = makeTagWithMask(new ArrayList<>(), new ArrayList<>());

        Method m = AbstractServiceStore.class.getDeclaredMethod("updateTagServiceDefForUpdatingDataMaskDef", RangerServiceDef.class, RangerServiceDef.class, long.class, String.class);
        m.setAccessible(true);

        Boolean updatedAdd = (Boolean) m.invoke(store, tagAdd, svcAdd, 5L * 1001L, "hdfs:");
        Assertions.assertTrue(updatedAdd);
        Assertions.assertTrue(tagAdd.getDataMaskDef().getMaskTypes().stream().anyMatch(mt -> "hdfs:MASK".equals(mt.getName())));
        Assertions.assertTrue(tagAdd.getDataMaskDef().getAccessTypes().stream().anyMatch(a -> "hdfs:read".equals(a.getName())));

        // Update scenario: change label/desc in svc; existing tag has matching itemId, prefixed name
        List<RangerServiceDef.RangerDataMaskTypeDef> svcMaskTypesUpd = new ArrayList<>();
        RangerServiceDef.RangerDataMaskTypeDef svcMaskUpd = new RangerServiceDef.RangerDataMaskTypeDef(1L, "MASK", "NEWLBL", null, null, null, null, null);
        svcMaskTypesUpd.add(svcMaskUpd);
        RangerServiceDef svcUpd = makeSvcWithMask(5L, "hdfs", svcMaskTypesUpd, svcMaskAccessAdd);

        RangerServiceDef tagUpd = makeTagWithMask(new ArrayList<>(tagAdd.getDataMaskDef().getMaskTypes()), new ArrayList<>(tagAdd.getDataMaskDef().getAccessTypes()));

        Boolean updatedUpd = (Boolean) m.invoke(store, tagUpd, svcUpd, 5L * 1001L, "hdfs:");
        Assertions.assertTrue(updatedUpd);
        Assertions.assertTrue(tagUpd.getDataMaskDef().getMaskTypes().stream().anyMatch(mt -> "hdfs:MASK".equals(mt.getName())));

        // Delete scenario: svc has no mask types; tag has one prefixed type -> should delete
        List<RangerServiceDef.RangerDataMaskTypeDef> svcMaskTypesDel = new ArrayList<>();
        RangerServiceDef svcDel = makeSvcWithMask(5L, "hdfs", svcMaskTypesDel, svcMaskAccessAdd);
        RangerServiceDef tagDel = makeTagWithMask(new ArrayList<>(tagAdd.getDataMaskDef().getMaskTypes()), new ArrayList<>(tagAdd.getDataMaskDef().getAccessTypes()));

        Boolean updatedDel = (Boolean) m.invoke(store, tagDel, svcDel, 5L * 1001L, "hdfs:");
        Assertions.assertTrue(updatedDel);
        Assertions.assertTrue(tagDel.getDataMaskDef().getMaskTypes().isEmpty());

        // No-change scenario: identical svc and tag -> expect false
        RangerServiceDef svcSame = makeSvcWithMask(6L, "kafka", new ArrayList<>(), new ArrayList<>());
        RangerServiceDef tagSame = makeTagWithMask(new ArrayList<>(), new ArrayList<>());
        Boolean updatedSame = (Boolean) m.invoke(store, tagSame, svcSame, 6L * 1001L, "kafka:");
        Assertions.assertFalse(updatedSame);
    }
}
