/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.plugin.conditionevaluator;

import org.apache.ranger.plugin.contextenricher.RangerTagForEval;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItemCondition;
import org.apache.ranger.plugin.model.RangerTag;
import org.apache.ranger.plugin.policyengine.RangerAccessRequest;
import org.apache.ranger.plugin.policyengine.RangerAccessRequestImpl;
import org.apache.ranger.plugin.policyengine.RangerAccessResource;
import org.apache.ranger.plugin.policyresourcematcher.RangerPolicyResourceMatcher;
import org.apache.ranger.plugin.util.RangerAccessRequestUtil;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static org.mockito.Mockito.mock;

/**
 * @generated by Cursor
 * @description <Unit Test for RangerTagConditions class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerTagConditions {
    @Test
    public void test01_anyOfExpectedTags_present() {
        RangerAnyOfExpectedTagsPresentConditionEvaluator evaluator = new RangerAnyOfExpectedTagsPresentConditionEvaluator();
        evaluator.setPolicyItemCondition(new RangerPolicyItemCondition(
                "__tagsAny", Arrays.asList("PCI", "PII")));
        evaluator.init();

        RangerAccessRequest request = buildRequestWithTags(new HashSet<>(Arrays.asList("PCI", "PHI")));
        Assertions.assertTrue(evaluator.isMatched(request));
    }

    @Test
    public void test02_anyOfExpectedTags_absent() {
        RangerAnyOfExpectedTagsPresentConditionEvaluator evaluator = new RangerAnyOfExpectedTagsPresentConditionEvaluator();
        evaluator.setPolicyItemCondition(new RangerPolicyItemCondition(
                "__tagsAny", Arrays.asList("PCI", "PII")));
        evaluator.init();

        RangerAccessRequest request = buildRequestWithTags(new HashSet<>(Arrays.asList("PHI")));
        Assertions.assertFalse(evaluator.isMatched(request));
    }

    @Test
    public void test03_allExpectedTags_present() {
        RangerTagsAllPresentConditionEvaluator evaluator = new RangerTagsAllPresentConditionEvaluator();
        evaluator.setPolicyItemCondition(new RangerPolicyItemCondition(
                "__tagsAll", Arrays.asList("PCI", "PII")));
        evaluator.init();

        RangerAccessRequest request = buildRequestWithTags(new HashSet<>(Arrays.asList("PCI", "PII", "PHI")));
        Assertions.assertTrue(evaluator.isMatched(request));
    }

    @Test
    public void test04_allExpectedTags_missing() {
        RangerTagsAllPresentConditionEvaluator evaluator = new RangerTagsAllPresentConditionEvaluator();
        evaluator.setPolicyItemCondition(new RangerPolicyItemCondition(
                "__tagsAll", Arrays.asList("PCI", "PII")));
        evaluator.init();

        RangerAccessRequest request = buildRequestWithTags(new HashSet<>(Collections.singletonList("PCI")));
        Assertions.assertFalse(evaluator.isMatched(request));
    }

    @Test
    public void test05_noneOfExpectedTags_present_returnsFalse() {
        RangerNoneOfExpectedTagsPresentConditionEvaluator evaluator = new RangerNoneOfExpectedTagsPresentConditionEvaluator();
        evaluator.setPolicyItemCondition(new RangerPolicyItemCondition(
                "__tagsNone", Arrays.asList("PCI", "PII")));
        evaluator.init();

        RangerAccessRequest request = buildRequestWithTags(new HashSet<>(Collections.singletonList("PII")));
        Assertions.assertFalse(evaluator.isMatched(request));
    }

    @Test
    public void test06_noneOfExpectedTags_absent_returnsTrue() {
        RangerNoneOfExpectedTagsPresentConditionEvaluator evaluator = new RangerNoneOfExpectedTagsPresentConditionEvaluator();
        evaluator.setPolicyItemCondition(new RangerPolicyItemCondition(
                "__tagsNone", Arrays.asList("PCI", "PII")));
        evaluator.init();

        RangerAccessRequest request = buildRequestWithTags(new HashSet<>(Collections.singletonList("PHI")));
        Assertions.assertTrue(evaluator.isMatched(request));
    }

    private RangerAccessRequest buildRequestWithTags(Set<String> tagTypes) {
        RangerAccessResource resource = mock(RangerAccessResource.class);

        RangerAccessRequestImpl request = new RangerAccessRequestImpl();
        request.setResource(resource);

        Set<RangerTagForEval> rangerTagForEvals = new HashSet<>();
        for (String type : tagTypes) {
            RangerTag tag = new RangerTag(type, Collections.singletonMap("attr1", type + "_v"));
            rangerTagForEvals.add(new RangerTagForEval(tag, RangerPolicyResourceMatcher.MatchType.SELF));
        }

        Map<String, Object> ctx = request.getContext();
        RangerAccessRequestUtil.setRequestTagsInContext(ctx, rangerTagForEvals);
        return request;
    }
}
