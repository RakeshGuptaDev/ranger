/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.plugin.model.validation;

import org.apache.hadoop.thirdparty.com.google.common.collect.Lists;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerAccessTypeDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerDataMaskDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerResourceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerRowFilterDef;
import org.apache.ranger.plugin.model.validation.RangerServiceDefHelper.Delegate;
import org.apache.ranger.plugin.resourcematcher.RangerAbstractResourceMatcher;
import org.apache.ranger.plugin.resourcematcher.RangerPathResourceMatcher;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertIterableEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNotSame;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
* @generated by Cursor
* @description <Unit Test for RangerServiceDefHelper class>
*/
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerServiceDefHelper {
    @Test
    public void test01_getResourceHierarchies() {
        RangerServiceDefHelper.cache.clear();
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef database       = createRealResourceDef("Database", null, 1, null);
        RangerResourceDef udf            = createRealResourceDef("UDF", "Database", 2, null);
        RangerResourceDef table          = createRealResourceDef("Table", "Database", 2, null);
        RangerResourceDef column         = createRealResourceDef("Column", "Table", 3, true);
        RangerResourceDef tableAttribute = createRealResourceDef("Table-Attribute", "Table", 3, true);

        List<RangerResourceDef> resourceDefs = Lists.newArrayList(column, database, table, tableAttribute, udf);
        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertTrue(helper.isResourceGraphValid());

        Set<List<RangerResourceDef>> hierarchies = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS);
        assertTrue(hierarchies.contains(Lists.newArrayList(database, udf)));
        assertTrue(hierarchies.contains(Lists.newArrayList(database, table, column)));
        assertTrue(hierarchies.contains(Lists.newArrayList(database, table, tableAttribute)));
    }

    @Test
    public void test02_isResourceGraphValid_detectCycle() {
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef a = createMockResourceDef("A", "D");
        RangerResourceDef b = createMockResourceDef("B", "C");
        RangerResourceDef c = createMockResourceDef("C", "D");
        RangerResourceDef d = createMockResourceDef("D", "A");

        List<RangerResourceDef> resourceDefs = Lists.newArrayList(a, b, c, d);
        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertFalse(helper.isResourceGraphValid());
    }

    @Test
    public void test03_isResourceGraphValid_forest() {
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef       database   = createMockResourceDef("database", "");
        RangerResourceDef       tableSpace = createMockResourceDef("table-space", "database", true);
        RangerResourceDef       table      = createMockResourceDef("table", "database");
        RangerResourceDef       column     = createMockResourceDef("column", "table", true);
        RangerResourceDef       namespace  = createMockResourceDef("namespace", "");
        RangerResourceDef       function   = createMockResourceDef("function", "namespace", true);
        RangerResourceDef       packagE    = createMockResourceDef("package", "namespace", true);
        List<RangerResourceDef> resourceDefs = Lists.newArrayList(database, tableSpace, table, column, namespace, function, packagE);

        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertTrue(helper.isResourceGraphValid());

        Set<List<RangerResourceDef>> hierarchies = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS);
        Set<List<String>> expectedHierarchies = new HashSet<>();
        expectedHierarchies.add(Lists.newArrayList("database", "table-space"));
        expectedHierarchies.add(Lists.newArrayList("database", "table", "column"));
        expectedHierarchies.add(Lists.newArrayList("namespace", "package"));
        expectedHierarchies.add(Lists.newArrayList("namespace", "function"));

        for (List<RangerResourceDef> aHierarchy : hierarchies) {
            List<String> resourceNames = helper.getAllResourceNamesOrdered(aHierarchy);
            assertTrue(expectedHierarchies.contains(resourceNames));
            expectedHierarchies.remove(resourceNames);
        }
        assertTrue(expectedHierarchies.isEmpty());
    }

    @Test
    public void test04_isResourceGraphValid_forest_singleNodeTrees() {
        RangerServiceDefHelper.cache.clear();
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef       database  = createRealResourceDef("database", null, 1, null);
        RangerResourceDef       server    = createRealResourceDef("server", null, 1, null);
        RangerResourceDef       namespace = createRealResourceDef("namespace", null, 1, null);
        RangerResourceDef       function  = createRealResourceDef("function", "namespace", 2, true);
        RangerResourceDef       packagE   = createRealResourceDef("package", "namespace", 2, true);
        List<RangerResourceDef> resourceDefs = Lists.newArrayList(database, server, namespace, function, packagE);

        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertTrue(helper.isResourceGraphValid());

        Set<List<RangerResourceDef>> hierarchies = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS);
        Set<List<String>> expectedHierarchies = new HashSet<>();
        expectedHierarchies.add(Lists.newArrayList("database"));
        expectedHierarchies.add(Lists.newArrayList("server"));
        expectedHierarchies.add(Lists.newArrayList("namespace", "package"));
        expectedHierarchies.add(Lists.newArrayList("namespace", "function"));

        for (List<RangerResourceDef> aHierarchy : hierarchies) {
            List<String> resourceNames = helper.getAllResourceNamesOrdered(aHierarchy);
            assertTrue(expectedHierarchies.contains(resourceNames));
            expectedHierarchies.remove(resourceNames);
        }
        assertTrue(expectedHierarchies.isEmpty());
    }

    @Test
    public void test05_cacheBehavior() {
        RangerServiceDefHelper.cache.clear();

        Delegate delegate    = mock(Delegate.class);
        Date     aDate       = getNow();
        String   serviceName = "a-service-def";

        when(delegate.getServiceFreshnessDate()).thenReturn(aDate);
        // removed unnecessary stubbing of getServiceName()

        RangerServiceDefHelper.cache.put(serviceName, delegate);

        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn(serviceName);
        when(serviceDef.getUpdateTime()).thenReturn(aDate);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);
        assertSame(delegate, helper.delegate);

        when(serviceDef.getUpdateTime()).thenReturn(getLastMonth());
        helper = new RangerServiceDefHelper(serviceDef);
        assertNotSame(delegate, helper.delegate);

        Delegate newDelegate = helper.delegate;
        helper = new RangerServiceDefHelper(serviceDef);
        assertSame(newDelegate, helper.delegate);
    }

    @Test
    public void test06_getResourceHierarchies_with_leaf_specification() {
        RangerServiceDefHelper.cache.clear();
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef database       = createRealResourceDef("Database", null, 1, false);
        RangerResourceDef udf            = createRealResourceDef("UDF", "Database", 2, null);
        RangerResourceDef table          = createRealResourceDef("Table", "Database", 2, true);
        RangerResourceDef column         = createRealResourceDef("Column", "Table", 3, true);
        RangerResourceDef tableAttribute = createRealResourceDef("Table-Attribute", "Table", 3, true);

        List<RangerResourceDef> resourceDefs = Lists.newArrayList(column, database, table, tableAttribute, udf);
        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertTrue(helper.isResourceGraphValid());

        Set<List<RangerResourceDef>> hierarchies = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS);
        assertTrue(hierarchies.contains(Lists.newArrayList(database, udf)));
        assertTrue(hierarchies.contains(Lists.newArrayList(database, table, column)));
        assertTrue(hierarchies.contains(Lists.newArrayList(database, table, tableAttribute)));
        assertTrue(hierarchies.contains(Lists.newArrayList(database, table)));
        assertFalse(hierarchies.contains(Lists.newArrayList(database)));
    }

    @Test
    public void test07_invalid_resourceHierarchies_with_leaf_specification() {
        RangerServiceDefHelper.cache.clear();
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef database       = createRealResourceDef("Database", null, 1, false);
        RangerResourceDef udf            = createRealResourceDef("UDF", "Database", 2, null);
        RangerResourceDef table          = createRealResourceDef("Table", "Database", 2, true);
        RangerResourceDef column         = createRealResourceDef("Column", "Table", 3, false);
        RangerResourceDef tableAttribute = createRealResourceDef("Table-Attribute", "Table", 3, true);
        List<RangerResourceDef> resourceDefs = Lists.newArrayList(column, database, table, tableAttribute, udf);

        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);
        assertFalse(helper.isResourceGraphValid());
    }

    @Test
    public void test08_getResourceHierarchies_filteredByKeys() {
        RangerServiceDefHelper.cache.clear();
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef database       = createRealResourceDef("Database", null, 1, null);
        RangerResourceDef udf            = createRealResourceDef("UDF", "Database", 2, null);
        RangerResourceDef table          = createRealResourceDef("Table", "Database", 2, null);
        RangerResourceDef column         = createRealResourceDef("Column", "Table", 3, true);
        RangerResourceDef tableAttribute = createRealResourceDef("Table-Attribute", "Table", 3, true);

        List<RangerResourceDef> resourceDefs = Lists.newArrayList(column, database, table, tableAttribute, udf);
        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);
        assertTrue(helper.isResourceGraphValid());

        Set<String> keys = new HashSet<>();
        keys.add("Database");
        keys.add("Table");

        Set<List<RangerResourceDef>> filtered = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS, keys);
        List<RangerResourceDef> expected1 = Lists.newArrayList(database, table, column);
        List<RangerResourceDef> expected2 = Lists.newArrayList(database, table, tableAttribute);

        assertTrue(filtered.contains(expected1));
        assertTrue(filtered.contains(expected2));
    }

    @Test
    public void test09_static_getServiceDefForPolicyFiltering_pathMatcherModification() {
        RangerServiceDef base = new RangerServiceDef();
        base.setName("svc");
        base.setUpdateTime(getNow());
        base.setAccessTypes(new ArrayList<>());

        RangerResourceDef pathRes = new RangerResourceDef();
        pathRes.setName("path");
        pathRes.setMatcher(RangerPathResourceMatcher.class.getName());
        Map<String, String> opts = new HashMap<>();
        opts.put(RangerPathResourceMatcher.OPTION_PATH_SEPARATOR, "/");
        pathRes.setMatcherOptions(opts);
        pathRes.setRecursiveSupported(true);
        pathRes.setLevel(1);

        RangerResourceDef otherRes = new RangerResourceDef();
        otherRes.setName("other");
        otherRes.setMatcher("com.example.OtherMatcher");
        otherRes.setLevel(1);

        base.setResources(Arrays.asList(pathRes, otherRes));

        RangerServiceDef modified = RangerServiceDefHelper.getServiceDefForPolicyFiltering(base);

        RangerResourceDef modifiedPath = null;
        RangerResourceDef modifiedOther = null;
        for (RangerResourceDef r : modified.getResources()) {
            if ("path".equals(r.getName())) {
                modifiedPath = r;
            } else if ("other".equals(r.getName())) {
                modifiedOther = r;
            }
        }
        assertNotNull(modifiedPath);
        assertNotNull(modifiedOther);
        assertEquals("false", modifiedPath.getMatcherOptions().get(RangerAbstractResourceMatcher.OPTION_WILD_CARD));
        assertFalse(Boolean.TRUE.equals(modifiedPath.getRecursiveSupported()));
        assertNull(modifiedOther.getMatcherOptions() == null ? null : modifiedOther.getMatcherOptions().get(RangerAbstractResourceMatcher.OPTION_WILD_CARD));
    }

    @Test
    public void test10_static_getFilterResourcesForAncestorPolicyFiltering_withDefaultDelimiterAndSuffix() {
        RangerServiceDef base = new RangerServiceDef();
        base.setName("svc");
        base.setUpdateTime(getNow());
        base.setAccessTypes(new ArrayList<>());

        RangerResourceDef pathRes = new RangerResourceDef();
        pathRes.setName("path");
        pathRes.setMatcher(RangerPathResourceMatcher.class.getName());
        pathRes.setLevel(1);
        // no PATH_SEPARATOR option to force default
        pathRes.setMatcherOptions(new HashMap<>());

        RangerResourceDef otherRes = new RangerResourceDef();
        otherRes.setName("other");
        otherRes.setMatcher("com.example.OtherMatcher");
        otherRes.setLevel(1);

        base.setResources(Arrays.asList(pathRes, otherRes));

        Map<String, String> filter = new HashMap<>();
        filter.put("path", "a/b");

        Map<String, String> out = RangerServiceDefHelper.getFilterResourcesForAncestorPolicyFiltering(base, filter);
        assertNotNull(out);
        assertEquals("a/b/" + RangerAbstractResourceMatcher.WILDCARD_ASTERISK, out.get("path"));
    }

    @Test
    public void test11_static_getFilterResourcesForAncestorPolicyFiltering_noMatchingReturnsNull() {
        RangerServiceDef base = new RangerServiceDef();
        base.setName("svc");
        base.setUpdateTime(getNow());
        base.setAccessTypes(new ArrayList<>());

        RangerResourceDef otherRes = new RangerResourceDef();
        otherRes.setName("other");
        otherRes.setMatcher("com.example.OtherMatcher");
        otherRes.setLevel(1);

        base.setResources(Collections.singletonList(otherRes));

        Map<String, String> filter = new HashMap<>();
        filter.put("path", "a/b");

        Map<String, String> out = RangerServiceDefHelper.getFilterResourcesForAncestorPolicyFiltering(base, filter);
        assertNull(out);
    }

    @Test
    public void test12_resourceHierarchyKeys_nullAuditUnknown() {
        RangerServiceDef serviceDef = createServiceDefWithSingleNodes("svc", Arrays.asList("A", "B"));
        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        Set<Set<String>> accessKeys = helper.getResourceHierarchyKeys(RangerPolicy.POLICY_TYPE_ACCESS);
        assertFalse(accessKeys.isEmpty());

        Set<Set<String>> auditKeys = helper.getResourceHierarchyKeys(RangerPolicy.POLICY_TYPE_AUDIT);
        assertIterableEquals(accessKeys, auditKeys);

        Set<Set<String>> nullKeys = helper.getResourceHierarchyKeys(null);
        assertIterableEquals(accessKeys, nullKeys);

        Set<Set<String>> unknown = helper.getResourceHierarchyKeys(9999);
        assertTrue(unknown.isEmpty());
    }

    @Test
    public void test13_isDataMaskSupported_variants() {
        RangerServiceDef serviceDef = new RangerServiceDef();
        serviceDef.setName("svc");
        serviceDef.setUpdateTime(getNow());
        serviceDef.setAccessTypes(new ArrayList<>());

        RangerResourceDef dmRes = new RangerResourceDef();
        dmRes.setName("DM");
        dmRes.setLevel(1);

        RangerDataMaskDef dmd = new RangerDataMaskDef();
        dmd.setResources(Collections.singletonList(dmRes));
        serviceDef.setDataMaskDef(dmd);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);
        assertTrue(helper.isDataMaskSupported());
        Set<String> match = new HashSet<>();
        match.add("DM");
        assertTrue(helper.isDataMaskSupported(match));

        Set<String> noMatch = new HashSet<>();
        noMatch.add("X");
        assertFalse(helper.isDataMaskSupported(noMatch));
    }

    @Test
    public void test14_isRowFilterSupported_variants() {
        RangerServiceDefHelper.cache.clear();
        RangerServiceDef serviceDef = new RangerServiceDef();
        serviceDef.setName("svc");
        serviceDef.setUpdateTime(getNow());
        serviceDef.setAccessTypes(new ArrayList<>());

        RangerResourceDef rfRes = new RangerResourceDef();
        rfRes.setName("RF");
        rfRes.setLevel(1);

        RangerRowFilterDef rfd = new RangerRowFilterDef();
        rfd.setResources(Collections.singletonList(rfRes));
        serviceDef.setRowFilterDef(rfd);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);
        assertTrue(helper.isRowFilterSupported());

        Set<String> match = new HashSet<>();
        match.add("RF");
        assertTrue(helper.isRowFilterSupported(match));

        Set<String> noMatch = new HashSet<>();
        noMatch.add("Y");
        assertFalse(helper.isRowFilterSupported(noMatch));
    }

    @Test
    public void test15_filterHierarchies_containsOnlyMandatoryResources() {
        RangerServiceDefHelper.cache.clear();
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setAccessTypes(new ArrayList<>());

        RangerResourceDef r1 = new RangerResourceDef();
        r1.setName("A");
        r1.setLevel(1);
        r1.setMandatory(true);

        RangerResourceDef r2 = new RangerResourceDef();
        r2.setName("B");
        r2.setParent("A");
        r2.setLevel(2);
        r2.setMandatory(true);
        r2.setIsValidLeaf(true);

        RangerResourceDef r3 = new RangerResourceDef();
        r3.setName("C");
        r3.setParent("B");
        r3.setLevel(3);
        r3.setMandatory(false);

        svc.setResources(Arrays.asList(r1, r2, r3));

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);
        Set<List<RangerResourceDef>> onlyMandatory = helper.filterHierarchies_containsOnlyMandatoryResources(RangerPolicy.POLICY_TYPE_ACCESS);
        assertTrue(onlyMandatory.contains(Lists.newArrayList(r1, r2)));
        assertFalse(onlyMandatory.contains(Lists.newArrayList(r1, r2, r3)));
    }

    @Test
    public void test16_isValidHierarchy_exact_vs_contains() {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setAccessTypes(new ArrayList<>());

        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setParent("A");
        resB.setLevel(2);

        RangerResourceDef resC = new RangerResourceDef();
        resC.setName("C");
        resC.setParent("B");
        resC.setLevel(3);

        svc.setResources(Arrays.asList(resA, resB, resC));

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);

        Set<String> subset = new HashSet<>();
        subset.add("A");
        subset.add("B");

        Set<String> exact = new HashSet<>();
        exact.add("A");
        exact.add("B");
        exact.add("C");

        assertTrue(helper.isValidHierarchy(RangerPolicy.POLICY_TYPE_ACCESS, subset, false));
        assertFalse(helper.isValidHierarchy(RangerPolicy.POLICY_TYPE_ACCESS, subset, true));
        assertTrue(helper.isValidHierarchy(RangerPolicy.POLICY_TYPE_ACCESS, exact, true));
    }

    @Test
    public void test17_hierarchyHasAllResources_true_false() {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setAccessTypes(new ArrayList<>());

        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setParent("A");
        resB.setLevel(2);

        List<RangerResourceDef> hierarchy = Arrays.asList(resA, resB);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);

        Set<String> yes = new HashSet<>();
        yes.add("A");
        yes.add("B");
        assertTrue(helper.hierarchyHasAllResources(hierarchy, yes));

        Set<String> no = new HashSet<>();
        no.add("A");
        no.add("C");
        assertFalse(helper.hierarchyHasAllResources(hierarchy, no));
    }

    @Test
    public void test18_getMandatoryResourceNames_and_getAllResourceNamesOrdered() {
        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);
        resA.setMandatory(true);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setParent("A");
        resB.setLevel(2);
        resB.setMandatory(false);

        List<RangerResourceDef> hierarchy = Arrays.asList(resA, resB);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(createServiceDef("svc", hierarchy));

        Set<String> mandatory = helper.getMandatoryResourceNames(hierarchy);
        assertTrue(mandatory.contains("A"));
        assertFalse(mandatory.contains("B"));

        List<String> ordered = helper.getAllResourceNamesOrdered(hierarchy);
        assertIterableEquals(Arrays.asList("A", "B"), ordered);
    }

    @Test
    public void test19_getOrderedResourceNames_orderingAndNull() {
        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(2);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setLevel(1);

        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setResources(Arrays.asList(resA, resB));
        svc.setAccessTypes(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc, false);

        List<String> input = Arrays.asList("A", "B");
        List<String> ordered = helper.getOrderedResourceNames(input);
        assertIterableEquals(Arrays.asList("B", "A"), ordered);

        List<String> nullOrdered = helper.getOrderedResourceNames(null);
        assertTrue(nullOrdered.isEmpty());
    }

    @Test
    public void test20_getResourceDef_nullPolicyTypeAndSpecific() {
        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);
        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setLevel(1);

        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setResources(Arrays.asList(resA, resB));
        svc.setAccessTypes(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);
        assertEquals("A", helper.getResourceDef("A", null).getName());
        assertNull(helper.getResourceDef("Z", RangerPolicy.POLICY_TYPE_ACCESS));
    }

    @Test
    public void test21_getWildcardEnabledResourceDef_cachingAndNullCase() {
        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);
        resA.setMatcher("com.example.X");
        resA.setMatcherOptions(new HashMap<>());

        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setResources(Collections.singletonList(resA));
        svc.setAccessTypes(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);
        RangerResourceDef wr1 = helper.getWildcardEnabledResourceDef("A", RangerPolicy.POLICY_TYPE_ACCESS);
        assertNotNull(wr1);
        assertEquals("true", wr1.getMatcherOptions().get(RangerAbstractResourceMatcher.OPTION_WILD_CARD));

        RangerResourceDef wr2 = helper.getWildcardEnabledResourceDef("A", RangerPolicy.POLICY_TYPE_ACCESS);
        assertSame(wr1, wr2);

        RangerResourceDef missing = helper.getWildcardEnabledResourceDef("Z", RangerPolicy.POLICY_TYPE_ACCESS);
        assertNull(missing);
        RangerResourceDef missingAgain = helper.getWildcardEnabledResourceDef("Z", RangerPolicy.POLICY_TYPE_ACCESS);
        assertNull(missingAgain);
    }

    @Test
    public void test22_expandImpliedAccessGrants_cases() {
        RangerServiceDefHelper.cache.clear();
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());

        RangerAccessTypeDef read = new RangerAccessTypeDef();
        read.setName("read");
        read.setImpliedGrants(Arrays.asList("view"));

        RangerAccessTypeDef write = new RangerAccessTypeDef();
        write.setName("write");
        write.setImpliedGrants(null);

        RangerAccessTypeDef viewMarker = new RangerAccessTypeDef();
        viewMarker.setName("view");
        viewMarker.setImpliedGrants(Arrays.asList("inspect"));

        svc.setAccessTypes(Arrays.asList(read, write));
        svc.setMarkerAccessTypes(Collections.singletonList(viewMarker));

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);

        assertTrue(helper.getImpliedAccessGrants().containsKey("read"));
        assertTrue(helper.getImpliedAccessGrants().containsKey("view"));
        assertFalse(helper.getImpliedAccessGrants().containsKey("write"));

        Set<String> empty = helper.expandImpliedAccessGrants(null);
        assertTrue(empty.isEmpty());

        Set<String> none = new HashSet<>();
        none.add("write");
        Set<String> noneOut = helper.expandImpliedAccessGrants(none);
        assertSame(none, noneOut);

        Set<String> some = new HashSet<>();
        some.add("read");
        Set<String> expanded = helper.expandImpliedAccessGrants(some);
        assertTrue(expanded.contains("read"));
        assertTrue(expanded.contains("view"));
        // expansion is not recursive; should not include implied of implied
        assertFalse(expanded.contains("inspect"));
    }

    @Test
    public void test23_patchServiceDefWithDefaultValues_setsLeafOnHierarchyEnds() {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setAccessTypes(new ArrayList<>());

        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);
        resA.setIsValidLeaf(null);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setParent("A");
        resB.setLevel(2);
        resB.setIsValidLeaf(null);

        RangerResourceDef resC = new RangerResourceDef();
        resC.setName("C");
        resC.setParent("B");
        resC.setLevel(3);
        resC.setIsValidLeaf(null);

        svc.setResources(Arrays.asList(resA, resB, resC));

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);
        helper.patchServiceDefWithDefaultValues();

        assertFalse(Boolean.TRUE.equals(resA.getIsValidLeaf()));
        assertFalse(Boolean.TRUE.equals(resB.getIsValidLeaf()));
        assertTrue(Boolean.TRUE.equals(resC.getIsValidLeaf()));
    }

    private RangerServiceDef createServiceDef(String name, List<RangerResourceDef> resources) {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName(name);
        svc.setUpdateTime(getNow());
        svc.setResources(resources);
        svc.setAccessTypes(new ArrayList<>());
        return svc;
    }

    private RangerServiceDef createServiceDefWithSingleNodes(String name, List<String> resourceNames) {
        List<RangerResourceDef> defs = new ArrayList<>();
        int level = 1;
        for (String rn : resourceNames) {
            RangerResourceDef d = new RangerResourceDef();
            d.setName(rn);
            d.setLevel(level++);
            defs.add(d);
        }
        return createServiceDef(name, defs);
    }

    private RangerResourceDef createMockResourceDef(String name, String parent) {
        RangerResourceDef resourceDef = mock(RangerResourceDef.class);
        when(resourceDef.getName()).thenReturn(name);
        when(resourceDef.getParent()).thenReturn(parent);
        return resourceDef;
    }

    private RangerResourceDef createMockResourceDef(String name, String parent, Boolean isValidLeaf) {
        RangerResourceDef resourceDef = mock(RangerResourceDef.class);
        when(resourceDef.getName()).thenReturn(name);
        when(resourceDef.getParent()).thenReturn(parent);
        if (isValidLeaf != null) {
            when(resourceDef.getIsValidLeaf()).thenReturn(isValidLeaf);
        }
        return resourceDef;
    }

    private Date getLastMonth() {
        Calendar cal = GregorianCalendar.getInstance();
        cal.add(Calendar.MONTH, 1);
        return cal.getTime();
    }

    private Date getNow() {
        return GregorianCalendar.getInstance().getTime();
    }

    private RangerResourceDef createRealResourceDef(String name, String parent, int level, Boolean isValidLeaf) {
        RangerResourceDef r = new RangerResourceDef();
        r.setName(name);
        r.setParent(parent);
        r.setLevel(level);
        r.setIsValidLeaf(isValidLeaf);
        return r;
    }
}
