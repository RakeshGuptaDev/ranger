/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.plugin.contextenricher.externalretrievers;

import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * @generated by Cursor
 * @description <Unit Test for GetFromURL class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestGetFromURL {
    @Test
    public void test01_toUserAttributes_flattensListsIntoCommaSeparated() throws Exception {
        GetFromURL gu = new GetFromURL();
        Method m = GetFromURL.class.getDeclaredMethod("toUserAttributes", Map.class);
        m.setAccessible(true);

        Map<String, Map<String, List<String>>> input = new HashMap<>();
        Map<String, List<String>> attrs = new HashMap<>();
        attrs.put("region", new ArrayList<String>() {
            {
                add("US");
                add("EU");
            }
        });
        input.put("alice", attrs);

        @SuppressWarnings("unchecked")
        Map<String, Map<String, String>> out = (Map<String, Map<String, String>>) m.invoke(gu, input);
        assertEquals("US,EU", out.get("alice").get("region"));
    }

    @Test
    public void test02_verifyToken_missingFields_throwsIOException() throws Exception {
        GetFromURL gu = new GetFromURL();
        Method decode = GetFromURL.class.getDeclaredMethod("decodeSecrets", String.class);
        decode.setAccessible(true);
        Method verify = GetFromURL.class.getDeclaredMethod("verifyToken", String.class);
        verify.setAccessible(true);

        String bare = "{\"headers\":[],\"params\":[]}"; // missing tokenUrl
        String encoded = (String) decode.invoke(gu, Base64.getEncoder().encodeToString(bare.getBytes()));
        assertThrows(IOException.class, () -> {
            try {
                verify.invoke(gu, encoded);
            } catch (Exception e) {
                if (e.getCause() instanceof IOException) {
                    throw (IOException) e.getCause();
                }
                throw new RuntimeException(e);
            }
        });
    }

    public static class Response {
        final int status;
        final String body;

        Response(int status, String body) {
            this.status = status;
            this.body = body == null ? "" : body;
        }
    }

    public static class MiniHttpServer implements AutoCloseable {
        private final Map<String, Response> routes;
        private ServerSocket server;
        private Thread thread;
        private volatile boolean running;

        MiniHttpServer(Map<String, Response> routes) {
            this.routes = routes;
        }

        int start() throws IOException {
            server = new ServerSocket(0);
            running = true;
            thread = new Thread(() -> {
                while (running && !server.isClosed()) {
                    try (Socket socket = server.accept();
                            BufferedReader reader = new BufferedReader(
                                    new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));
                            PrintWriter writer = new PrintWriter(
                                    new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8), true)) {
                        String requestLine = reader.readLine();
                        if (requestLine == null) {
                            continue;
                        }
                        String[] parts = requestLine.split(" ");
                        String path = parts.length >= 2 ? parts[1] : "/";
                        // consume headers
                        String line;
                        while ((line = reader.readLine()) != null && !line.isEmpty()) {
                            /* ignore */ }
                        Response resp = routes.getOrDefault(path, new Response(404, ""));
                        byte[] bodyBytes = resp.body.getBytes(StandardCharsets.UTF_8);
                        writer.printf("HTTP/1.1 %d %s\r\n", resp.status, resp.status == 200 ? "OK" : "ERR");
                        writer.printf("Content-Length: %d\r\n", bodyBytes.length);
                        writer.print("Content-Type: application/json\r\n");
                        writer.print("Connection: close\r\n\r\n");
                        writer.flush();
                        socket.getOutputStream().write(bodyBytes);
                        socket.getOutputStream().flush();
                    } catch (IOException e) {
                        if (running) {
                            // ignore transient errors while running
                        }
                    }
                }
            }, "mini-http");
            thread.setDaemon(true);
            thread.start();
            return server.getLocalPort();
        }

        @Override
        public void close() throws IOException {
            running = false;
            if (server != null && !server.isClosed()) {
                server.close();
            }
            try {
                if (thread != null) {
                    thread.join(1000);
                }
            } catch (InterruptedException ignored) {
                Thread.currentThread().interrupt();
            }
        }
    }

    @Test
    public void test03_getFromURL_withLocalServer_success() throws Exception {
        Map<String, Response> routes = new HashMap<>();
        routes.put("/token", new Response(200, "{\"access_token\":\"t123\"}"));
        routes.put("/user", new Response(200, "{\"body\":{\"alice\":{\"region\":[\"US\",\"EU\"]}}}"));
        try (MiniHttpServer server = new MiniHttpServer(routes)) {
            int port = server.start();
            File secrets = File.createTempFile("secrets", ".txt");
            try {
                String json = "{\"tokenUrl\":\"http://127.0.0.1:" + port
                        + "/token\",\"headers\":[{\"Content-Type\":\"application/x-www-form-urlencoded\"}],\"params\":[]}";
                String encoded = Base64.getEncoder().encodeToString(json.getBytes(StandardCharsets.UTF_8));
                Files.write(secrets.toPath(), encoded.getBytes(StandardCharsets.UTF_8));

                GetFromURL gu = new GetFromURL();
                Map<String, Map<String, String>> out = gu.getFromURL("http://127.0.0.1:" + port + "/user",
                        secrets.getAbsolutePath());
                assertEquals("US,EU", out.get("alice").get("region"));
            } finally {
                secrets.delete();
            }
        }
    }

    @Test
    public void test04_getFromURL_httpError_throws() throws Exception {
        Map<String, Response> routes = new HashMap<>();
        routes.put("/token", new Response(200, "{\"access_token\":\"t123\"}"));
        routes.put("/user", new Response(500, ""));
        try (MiniHttpServer server = new MiniHttpServer(routes)) {
            int port = server.start();
            File secrets = File.createTempFile("secrets", ".txt");
            try {
                String json = "{\"tokenUrl\":\"http://127.0.0.1:" + port
                        + "/token\",\"headers\":[{\"Content-Type\":\"application/x-www-form-urlencoded\"}],\"params\":[]}";
                String encoded = Base64.getEncoder().encodeToString(json.getBytes(StandardCharsets.UTF_8));
                Files.write(secrets.toPath(), encoded.getBytes(StandardCharsets.UTF_8));

                GetFromURL gu = new GetFromURL();
                assertThrows(IOException.class,
                        () -> gu.getFromURL("http://127.0.0.1:" + port + "/user", secrets.getAbsolutePath()));
            } finally {
                secrets.delete();
            }
        }
    }

    @Test
    public void test05_getBearerToken_httpError_throws() throws Exception {
        Map<String, Response> routes = new HashMap<>();
        routes.put("/badtoken", new Response(400, ""));
        routes.put("/user", new Response(200, "{\"body\":{}}"));
        try (MiniHttpServer server = new MiniHttpServer(routes)) {
            int port = server.start();
            File secrets = File.createTempFile("secrets", ".txt");
            try {
                String json = "{\"tokenUrl\":\"http://127.0.0.1:" + port
                        + "/badtoken\",\"headers\":[{\"Content-Type\":\"application/x-www-form-urlencoded\"}],\"params\":[]}";
                String encoded = Base64.getEncoder().encodeToString(json.getBytes(StandardCharsets.UTF_8));
                Files.write(secrets.toPath(), encoded.getBytes(StandardCharsets.UTF_8));

                GetFromURL gu = new GetFromURL();
                assertThrows(IOException.class,
                        () -> gu.getFromURL("http://127.0.0.1:" + port + "/user", secrets.getAbsolutePath()));
            } finally {
                secrets.delete();
            }
        }
    }

    @Test
    public void test06_verifyToken_invalidContentType_throws() throws Exception {
        GetFromURL gu = new GetFromURL();
        Method verify = GetFromURL.class.getDeclaredMethod("verifyToken", String.class);
        verify.setAccessible(true);
        String bad = "{\"tokenUrl\":\"http://host/token\",\"headers\":[{\"Content-Type\":\"application/json\"}],\"params\":[]}";
        assertThrows(IOException.class, () -> {
            try {
                verify.invoke(gu, bad);
            } catch (Exception e) {
                if (e.getCause() instanceof IOException) {
                    throw (IOException) e.getCause();
                }
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void test07_decodeSecrets_roundTrip() throws Exception {
        GetFromURL gu = new GetFromURL();
        Method decode = GetFromURL.class.getDeclaredMethod("decodeSecrets", String.class);
        decode.setAccessible(true);
        String original = "hello";
        String b64 = Base64.getEncoder().encodeToString(original.getBytes(StandardCharsets.UTF_8));
        String decoded = (String) decode.invoke(gu, b64);
        assertEquals(original, decoded);
    }
}
