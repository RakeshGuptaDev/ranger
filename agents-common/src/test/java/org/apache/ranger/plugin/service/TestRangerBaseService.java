/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.plugin.service;

import org.apache.ranger.authorization.hadoop.config.RangerAdminConfig;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerService;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerAccessTypeDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerResourceDef;
import org.apache.ranger.plugin.model.validation.RangerServiceDefHelper;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
* @generated by Cursor
* @description <Unit Test for RangerBaseService class>
*/
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerBaseService {
    public static class DummyService extends RangerBaseService {
        @Override
        public Map<String, Object> validateConfig() {
            Map<String, Object> m = new HashMap<>();
            m.put("ok", Boolean.TRUE);
            return m;
        }

        @Override
        public List<String> lookupResource(ResourceLookupContext context) {
            return Collections.singletonList("X");
        }
    }

    private RangerServiceDef buildServiceDef() {
        RangerServiceDef def = new RangerServiceDef();
        def.setId(1L);
        def.setName("dummy");

        List<RangerResourceDef> resources = new ArrayList<>();
        RangerResourceDef db = new RangerResourceDef();
        db.setName("database");
        db.setLevel(1);
        db.setRecursiveSupported(Boolean.TRUE);
        db.setMandatory(Boolean.TRUE);
        db.setIsValidLeaf(Boolean.FALSE);
        RangerResourceDef table = new RangerResourceDef();
        table.setName("table");
        table.setLevel(2);
        table.setParent("database");
        table.setRecursiveSupported(Boolean.TRUE);
        table.setMandatory(Boolean.TRUE);
        table.setIsValidLeaf(Boolean.TRUE);
        resources.add(db);
        resources.add(table);
        def.setResources(resources);

        List<RangerAccessTypeDef> accessTypes = new ArrayList<>();
        RangerAccessTypeDef select = new RangerAccessTypeDef();
        select.setName("select");
        RangerAccessTypeDef update = new RangerAccessTypeDef();
        update.setName("update");
        accessTypes.add(select);
        accessTypes.add(update);
        def.setAccessTypes(accessTypes);

        Map<String, String> options = new HashMap<>();
        options.put("create.default.policy.per.hierarchy", "true");
        def.setOptions(options);

        return def;
    }

    private RangerService buildService(Map<String, String> configs) {
        RangerService svc = new RangerService();
        svc.setName("svc1");
        svc.setType("dummy");
        svc.setConfigs(configs);
        return svc;
    }

    @Test
    public void test1_DefaultPoliciesCreatedPerHierarchy() throws Exception {
        DummyService svc = new DummyService();
        RangerServiceDef def = buildServiceDef();
        RangerService service = buildService(new LinkedHashMap<>());

        svc.init(def, service);

        List<RangerPolicy> policies = svc.getDefaultRangerPolicies();
        assertNotNull(policies);
        assertTrue(policies.size() >= 1);
        RangerPolicy p0 = policies.get(0);
        assertEquals("svc1", p0.getService());
        assertTrue(p0.getResources().containsKey("database"));
        assertTrue(p0.getResources().containsKey("table"));
        assertTrue(p0.getPolicyItems().get(0).getAccesses().stream().anyMatch(a -> "select".equals(a.getType())));
    }

    @Test
    public void test2_CreateDefaultPolicyResourceAndAllowedAccesses() {
        DummyService svc = new DummyService();
        RangerServiceDef def = buildServiceDef();
        RangerService service = buildService(new LinkedHashMap<>());
        svc.init(def, service);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(def);
        Set<List<RangerResourceDef>> hierarchies = helper.filterHierarchies_containsOnlyMandatoryResources(RangerPolicy.POLICY_TYPE_ACCESS);
        assertTrue(!hierarchies.isEmpty());
        List<RangerResourceDef> first = hierarchies.iterator().next();

        Map<String, RangerPolicy.RangerPolicyResource> res = svc.createDefaultPolicyResource(first);
        assertTrue(res.containsKey("database"));
        assertTrue(res.get("database").getIsRecursive());

        List<RangerPolicy.RangerPolicyItemAccess> accesses = svc.getAllowedAccesses(res);
        assertTrue(accesses.stream().anyMatch(a -> "select".equals(a.getType())));
        assertTrue(accesses.stream().anyMatch(a -> "update".equals(a.getType())));
    }

    @Test
    public void test3_CustomDefaultPoliciesFromConfigs() throws Exception {
        DummyService svc = new DummyService();
        RangerServiceDef def = buildServiceDef();
        Map<String, String> cfg = new LinkedHashMap<>();
        cfg.put("default-policy.1.name", "p-custom");
        cfg.put("default-policy.1.description", "desc");
        cfg.put("default-policy.1.isDenyAllElse", "true");
        cfg.put("default-policy.1.resource.database", "db1,db2");
        cfg.put("default-policy.1.resource.table", "t1");
        cfg.put("default-policy.1.policyItem.1.users", "u1,u2");
        cfg.put("default-policy.1.policyItem.1.groups", "g1");
        cfg.put("default-policy.1.policyItem.1.roles", "r1");
        cfg.put("default-policy.1.policyItem.1.accessTypes", "select,update");
        cfg.put("default-policy.1.policyItem.1.isDelegateAdmin", "true");

        RangerService service = buildService(cfg);
        svc.init(def, service);

        List<RangerPolicy> policies = svc.getDefaultRangerPolicies();
        assertNotNull(policies);
        boolean found = policies.stream().anyMatch(p -> p.getResources().containsKey("database")
                && p.getResources().containsKey("table")
                && p.getPolicyItems() != null
                && p.getPolicyItems().stream().anyMatch(pi -> pi.getAccesses() != null && pi.getAccesses().stream().anyMatch(a -> "select".equals(a.getType()) || "update".equals(a.getType()))));
        assertTrue(found);
    }

    @Test
    public void test4_GetLookupUserKerberosBranches() throws IOException {
        DummyService svc = new DummyService();
        RangerAdminConfig rac = RangerAdminConfig.getInstance();
        String user = svc.getLookupUser("kerberos", rac.get("ranger.lookup.kerberos.principal"), rac.get("ranger.lookup.kerberos.keytab"));
        assertEquals(null, user);
    }

    @Test
    public void test5_CreateDefaultPolicyPerHierarchy_FromServiceAndServiceDefOptions() throws Exception {
        DummyService svc = new DummyService();
        RangerServiceDef def = buildServiceDef();
        // remove option from service-def to test default true
        def.setOptions(new HashMap<>());
        Map<String, String> cfg1 = new LinkedHashMap<>();
        // no explicit config -> should fallback to default true
        RangerService service1 = buildService(cfg1);
        svc.init(def, service1);
        List<RangerPolicy> p1 = svc.getDefaultRangerPolicies();
        assertFalse(p1.isEmpty());

        // now set service config to false to suppress creation
        Map<String, String> cfg2 = new LinkedHashMap<>();
        cfg2.put("create.default.policy.per.hierarchy", "false");
        RangerService service2 = buildService(cfg2);
        svc.init(def, service2);
        List<RangerPolicy> p2 = svc.getDefaultRangerPolicies();
        assertTrue(p2.isEmpty());
    }

    @Test
    public void test6_GetResourcesForPrefix_WithFlags() throws Exception {
        DummyService svc = new DummyService();
        RangerServiceDef def = buildServiceDef();
        Map<String, String> cfg = new LinkedHashMap<>();
        cfg.put("default-policy.1.name", "p1");
        cfg.put("default-policy.1.resource.database", "db1,db2");
        cfg.put("default-policy.1.resource.database.is-excludes", "true");
        cfg.put("default-policy.1.resource.database.is-recursive", "true");
        cfg.put("default-policy.1.policyItem.1.users", "u1");
        cfg.put("default-policy.1.policyItem.1.accessTypes", "select");
        cfg.put("setup.additional.default.policies", "true");
        RangerService service = buildService(cfg);
        svc.init(def, service);
        List<RangerPolicy> policies = svc.getDefaultRangerPolicies();
        assertTrue(policies.stream().anyMatch(p -> Boolean.TRUE.equals(p.getResources().get("database").getIsExcludes())
                && Boolean.TRUE.equals(p.getResources().get("database").getIsRecursive())));
    }

    @Test
    public void test7_GetUserAndGroupLists_MergesServiceConfigs() {
        DummyService svc = new DummyService();
        RangerServiceDef def = buildServiceDef();
        Map<String, String> cfg = new LinkedHashMap<>();
        cfg.put("username", "svcUser");
        cfg.put("default.policy.users", "u1,u2");
        cfg.put("default.policy.groups", "g1,g2");
        RangerService service = buildService(cfg);
        svc.init(def, service);

        // access private via public API: getDefaultRangerPolicies should include these in first policy item
        List<RangerPolicy> policies;
        try {
            policies = svc.getDefaultRangerPolicies();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        RangerPolicy first = policies.get(0);
        List<String> users = first.getPolicyItems().get(0).getUsers();
        List<String> groups = first.getPolicyItems().get(0).getGroups();
        assertTrue(users.contains("svcUser"));
        assertTrue(users.contains("u1") && users.contains("u2"));
        assertTrue(groups.contains("g1") && groups.contains("g2"));
    }

    @Test
    public void test8_GetLookupUser_SimpleAuthReturnsNull() throws IOException {
        DummyService svc = new DummyService();
        String user = svc.getLookupUser("simple", null, null);
        assertEquals(null, user);
    }
}
